<template>
    <GalleryAndResult :value="{ series: series, labels: labels }" hasMultipleValues :importCode="importCode" :exampleCode="exampleCode">

        <div style="height: 300px;">
            <LineChart :labels="labels"
                       :series="series"
                       :hideLegend="isLegendHidden"
                       :labelDateFormat="labelDateFormat"
                       :legendAlign="legendAlign"
                       :legendPosition="legendPosition"
                       :linear="isLinear"
                       :lineStyle="lineStyle"
                       :stack="isStacked"
                       :title="title"
                       :tooltip="tooltip"
                       :tooltipTitle="tooltipTitle"
                       :type="isPercent ? 'percent' : isPercent === false ? 'number' : undefined"
                       :unfilled="isUnfilled"
                       :xLabel="xLabel"
                       :xMaxTickCount="xMaxTickCount"
                       :xShowGridLines="xShowGridLines"
                       :yHideGridLines="yHideGridLines"
                       :yLabel="yLabel"
                       :yMaxTickCount="yMaxTickCount"
                       :ySuggestedMax="ySuggestedMax"
                       :ySuggestedMin="ySuggestedMin"
                       :yTickCount="yTickCount" />
        </div>

        <template #settings>
            <div class="settings">
                <ContentSection title="Settings">
                    <ContentStack title="General">
                        <div class="autolayout">
                            <TextBox :modelValue="title ?? ''"
                                     label="Chart Title"
                                     @update:modelValue="title = $event" />
                        </div>
                    </ContentStack>

                    <ContentStack title="Data">
                        <div class="autolayout">
                            <NumberUpDown v-model="seriesCount"
                                          label="Series Count"
                                          :min="1"
                                          :max="8" />

                            <div class="button-wrapper">
                                <RockButton btnType="primary"
                                            @click="onRandomizeDataClicked">Randomize Data</RockButton>
                            </div>

                            <DropDownList :modelValue="labelDateFormat ?? ''"
                                          help="If specified, then the labels array must have ISO 8601-formatted dates. If not specified, the labels will be treated as simple strings."
                                          :items="labelDateFormatItems"
                                          label="Label Date Format"
                                          @update:modelValue="labelDateFormat = <LabelDateFormat>$event" />

                            <DropDownList :modelValue="lineStyle ?? ''"
                                          :items="lineStyleItems"
                                          label="Line Style"
                                          @update:modelValue="lineStyle = <LineStyle>$event" />

                            <Switch :modelValue="isStacked ?? false"
                                    label="Stacked"
                                    @update:modelValue="isStacked = $event" />

                            <Switch :modelValue="isUnfilled ?? false"
                                    label="Unfilled"
                                    @update:modelValue="isUnfilled = $event" />

                            <Switch :modelValue="isLinear ?? false"
                                    help="Connects data points with straight line segments instead of curves."
                                    label="Linear"
                                    @update:modelValue="isLinear = $event" />

                            <Switch :modelValue="isPercent ?? false"
                                    help="For 'percent', the data must be in decimal form (e.g., 0.1 for 10%)."
                                    label="Percent"
                                    @update:modelValue="isPercent = $event" />

                            <Switch :modelValue="hasCustomTooltip ?? false"
                                    label="Custom Tooltip"
                                    @update:modelValue="hasCustomTooltip = $event" />
                        </div>
                    </ContentStack>

                    <ContentStack title="Legend">
                        <div class="autolayout">
                            <DropDownList :modelValue="legendPosition ?? ''"
                                          :items="legendPositionItems"
                                          label="Position"
                                          @update:modelValue="legendPosition = <LegendPosition>$event" />

                            <DropDownList :modelValue="legendAlign ?? ''"
                                          :items="legendAlignItems"
                                          label="Alignment"
                                          @update:modelValue="legendAlign = <LegendAlign>$event" />

                            <Switch :modelValue="isLegendHidden ?? false"
                                    label="Hide"
                                    @update:modelValue="isLegendHidden = $event" />
                        </div>
                    </ContentStack>

                    <ContentStack title="X-Axis">
                        <div class="autolayout">
                            <TextBox :modelValue="xLabel ?? ''"
                                     label="Label"
                                     @update:modelValue="xLabel = $event" />

                            <NumberBox v-model="xMaxTickCount"
                                       label="Max Tick Count" />

                            <Switch :modelValue="xShowGridLines ?? false"
                                    label="Show Grid Lines"
                                    @update:modelValue="xShowGridLines = $event" />
                        </div>
                    </ContentStack>

                    <ContentStack title="Y-Axis">
                        <div class="autolayout">
                            <TextBox :modelValue="yLabel ?? ''"
                                     label="Label"
                                     @update:modelValue="yLabel = $event" />

                            <Switch :modelValue="yHideGridLines ?? false"
                                    label="Hide Grid Lines"
                                    @update:modelValue="yHideGridLines = $event" />

                            <NumberBox v-model="yTickCount"
                                       label="Tick Count" />

                            <NumberBox v-model="yMaxTickCount"
                                       label="Max Tick Count" />

                            <NumberBox v-model="ySuggestedMin"
                                       label="Suggested Min" />

                            <NumberBox v-model="ySuggestedMax"
                                       label="Suggested Max" />
                        </div>
                    </ContentStack>
                </ContentSection>
            </div>
        </template>
    </GalleryAndResult>
</template>

<style scoped>
.button-wrapper {
    display: flex;
    align-items: center;
}

.settings {
    max-height: 350px;
    overflow: auto;
}

.autolayout {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    column-gap: var(--spacing-small);
}
</style>

<script setup lang="ts">
    import { computed, ref, watch } from "vue";
    import GalleryAndResult from "./common/galleryAndResult.partial.obs";
    import { getSfcControlImportPath } from "./common/utils.partial";
    import ContentSection from "@Obsidian/Controls/contentSection.obs";
    import ContentStack from "@Obsidian/Controls/contentStack.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import LineChart from "@Obsidian/Controls/lineChart.obs";
    import NumberBox from "@Obsidian/Controls/numberBox.obs";
    import NumberUpDown from "@Obsidian/Controls/numberUpDown.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import Switch from "@Obsidian/Controls/switch.obs";
    import TextBox from "@Obsidian/Controls/textBox.obs";
    import { LabelDateFormat, LegendAlign, LegendPosition, LineStyle, LineSeries, LineStyleDescription, LabelDateFormatDescription, LegendAlignDescription, LegendPositionDescription, TooltipCallback } from "@Obsidian/Core/Controls/chart";
    import { Enumerable } from "@Obsidian/Utility/linq";
    import { isNullish } from "@Obsidian/Utility/util";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";

    const importCode = getSfcControlImportPath("chart");
    const labels = [
        "2024-01-01T00:00:00",
        "2024-02-01T00:00:00",
        "2024-03-01T00:00:00",
        "2024-04-01T00:00:00",
        "2024-05-01T00:00:00",
        "2024-06-01T00:00:00",
        "2024-07-01T00:00:00",
        "2024-08-01T00:00:00",
        "2024-09-01T00:00:00",
        "2024-10-01T00:00:00",
        "2024-11-01T00:00:00",
        "2024-12-01T00:00:00",
        "2025-01-01T00:00:00",
        "2025-02-01T00:00:00",
        "2025-03-01T00:00:00",
        "2025-04-01T00:00:00"
    ];
    const legendPositionItems = [
        { text: LegendPositionDescription[LegendPosition.Top], value: LegendPosition.Top },
        { text: LegendPositionDescription[LegendPosition.Bottom], value: LegendPosition.Bottom },
        { text: LegendPositionDescription[LegendPosition.Left], value: LegendPosition.Left },
        { text: LegendPositionDescription[LegendPosition.Right], value: LegendPosition.Right }
    ];
    const legendAlignItems = [
        { text: LegendAlignDescription[LegendAlign.Start], value: LegendAlign.Start },
        { text: LegendAlignDescription[LegendAlign.Center], value: LegendAlign.Center },
        { text: LegendAlignDescription[LegendAlign.End], value: LegendAlign.End }
    ];
    const labelDateFormatItems = [
        { text: LabelDateFormatDescription[LabelDateFormat.Auto], value: LabelDateFormat.Auto },
        { text: LabelDateFormatDescription[LabelDateFormat.Day], value: LabelDateFormat.Day },
        { text: LabelDateFormatDescription[LabelDateFormat.Week], value: LabelDateFormat.Week },
        { text: LabelDateFormatDescription[LabelDateFormat.Month], value: LabelDateFormat.Month },
        { text: LabelDateFormatDescription[LabelDateFormat.Year], value: LabelDateFormat.Year }
    ];
    const lineStyleItems = [
        { text: LineStyleDescription[LineStyle.Solid], value: LineStyle.Solid },
        { text: LineStyleDescription[LineStyle.Dashed], value: LineStyle.Dashed },
        { text: LineStyleDescription[LineStyle.Dotted], value: LineStyle.Dotted }
    ];

    // #region Values

    const minValue = ref<number>(0);
    const maxValue = ref<number>(100);
    const hasCustomTooltip = ref<boolean | undefined>();
    const xShowGridLines = ref<boolean | undefined>();
    const yHideGridLines = ref<boolean | undefined>();
    const xMaxTickCount = ref<number | undefined>();
    const yMaxTickCount = ref<number | undefined>();
    const isUnfilled = ref<boolean | undefined>();
    const isLinear = ref<boolean | undefined>();
    const isStacked = ref<boolean | undefined>();
    const seriesCount = ref<number>(4);
    const legendPosition = ref<LegendPosition | undefined>();
    const legendAlign = ref<LegendAlign | undefined>();
    const isLegendHidden = ref<boolean | undefined>();
    const labelDateFormat = ref<LabelDateFormat | undefined>(LabelDateFormat.Auto);
    const lineStyle = ref<LineStyle | undefined>();
    const isPercent = ref<boolean | undefined>();
    const yTickCount = ref<number | undefined>();
    const xLabel = ref<string | undefined>("X Axis");
    const yLabel = ref<string | undefined>("Y Axis");
    const title = ref<string | undefined>("Chart Title");
    const ySuggestedMin = ref<number | undefined>();
    const ySuggestedMax = ref<number | undefined>();
    const series = ref<LineSeries[]>([
        {
            label: "Small Group",
            data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        },
        {
            label: "Baptism",
            data: [0, 5, 7, 11, 13, 15, 16, 18, 19, 20, 20, 20, 22, 24, 27, 30],
        },
        {
            label: "Starting Point Class",
            data: [0, 2, 3, 4, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10],
        },
        {
            label: "Serve",
            data: [0, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6],
        }]);

    // #endregion Values

    // #region Computed Values

    const exampleCode = computed<string>(() => {
        let lineChartProps: string[] = [
            `:labels="labels"`,
            `:series="series"`
        ];

        if (!isNullish(isLegendHidden.value)) {
            lineChartProps.push(`hideLegend="${isLegendHidden.value}"`);
        }
        if (!isNullish(labelDateFormat.value)) {
            lineChartProps.push(`labelDateFormat="${labelDateFormat.value}"`);
        }

        if (!isNullish(legendAlign.value)) {
            lineChartProps.push(`legendAlign="${legendAlign.value}"`);
        }
        if (!isNullish(legendPosition.value)) {
            lineChartProps.push(`legendPosition="${legendPosition.value}"`);
        }
        if (!isNullish(isLinear.value)) {
            lineChartProps.push(`linear="${isLinear.value}"`);
        }
        if (!isNullish(lineStyle.value)) {
            lineChartProps.push(`lineStyle="${lineStyle.value}"`);
        }
        if (!isNullish(isStacked.value)) {
            lineChartProps.push(`stack="${isStacked.value}"`);
        }
        if (title.value) {
            lineChartProps.push(`title="${title.value}"`);
        }
        if (!isNullish(isPercent.value)) {
            if (isPercent.value) {
                lineChartProps.push(`type="percent"`);
            }
            else {
                lineChartProps.push(`type="number"`);
            }
        }
        if (!isNullish(isUnfilled.value)) {
            lineChartProps.push(`unfilled="${isUnfilled.value}"`);
        }
        if (xLabel.value) {
            lineChartProps.push(`xLabel="${xLabel.value}"`);
        }
        if (!isNullish(xMaxTickCount.value)) {
            lineChartProps.push(`:xMaxTickCount="${xMaxTickCount.value}"`);
        }
        if (!isNullish(xShowGridLines.value)) {
            lineChartProps.push(`xShowGridLines="${xShowGridLines.value}"`);
        }
        if (!isNullish(yHideGridLines.value)) {
            lineChartProps.push(`yHideGridLines="${yHideGridLines.value}"`);
        }
        if (yLabel.value) {
            lineChartProps.push(`yLabel="${yLabel.value}"`);
        }
        if (!isNullish(yMaxTickCount.value)) {
            lineChartProps.push(`:yMaxTickCount="${yMaxTickCount.value}"`);
        }
        if (!isNullish(ySuggestedMin.value)) {
            lineChartProps.push(`:ySuggestedMin="${ySuggestedMin.value}"`);
        }
        if (!isNullish(ySuggestedMax.value)) {
            lineChartProps.push(`:ySuggestedMax="${ySuggestedMax.value}"`);
        }
        if (!isNullish(yTickCount.value)) {
            lineChartProps.push(`:yTickCount="${yTickCount.value}"`);
        }

        const prefix = "<LineChart ";
        const spaces = " ".repeat(prefix.length);
        return `${prefix}${lineChartProps.join(`\n${spaces}`)} />`;
    });

    const tooltip = computed<TooltipCallback | undefined>(() => {
        if (hasCustomTooltip.value) {
            return (ctx) => {
                if (isPercent.value) {
                    return `The ${ctx.seriesLabel} value for ${ctx.formattedLabel} is ${ctx.value?.toLocaleString(undefined, { style: "percent", maximumFractionDigits: 2 })}.`;
                }
                else {
                    return `The ${ctx.seriesLabel} value for ${ctx.formattedLabel} is ${ctx.value?.toLocaleString()}.`;
                }
            };
        }
    });

    const tooltipTitle = computed<TooltipCallback | undefined>(() => {
        if (hasCustomTooltip.value) {
            return (ctx) => {
                return RockDateTime.parseISO(ctx.label)?.toLocaleString({ dateStyle: "long" }) ?? ctx.formattedLabel;
            };
        }
    });

    // #endregion Computed Values

    // #region Functions

    function generateSeries(): LineSeries[] {
        return Enumerable
            .from(Array(seriesCount.value).keys())
            .select(i => generateOneSeries(i))
            .toArray();
    }

    function generateOneSeries(i: number): LineSeries {
        const min = Math.min(minValue.value, maxValue.value);
        const max = Math.max(minValue.value, maxValue.value);
        let data = generateTrendingRandomData(labels.length, min, max, true);
        if (isPercent.value) {
            data = Enumerable.from(data).select(n => typeof n === "number" ? n / 100 : n).toArray();
        }
        const s: LineSeries = {
            label: `Series ${i + 1}`,
            data: data,
            // isUnfilled: isUnfilled.value,
            // isLinear: isLinear.value,
            // lineStyle: lineStyle.value
        };
        return s;
    }

    function generateTrendingRandomData(
        count: number,
        min: number,
        max: number,
        startAtMin: boolean = true
    ): number[] {
        if (count <= 0) {
            return [];
        }

        // Ensure min is less than or equal to max
        if (min > max) {
            [min, max] = [max, min]; // Swap if min is greater than max
        }

        const data: number[] = [];
        let currentValue: number;

        // Set the initial value, potentially starting exactly at 'min'
        currentValue = startAtMin ? min : min + (max - min) * 0.1;

        // Randomly decide if this run should trend downwards (~25% of the time)
        const isDownwardTrend = Math.random() < 0.25;

        // Generate a random upward/downward bias for this function call
        const randomTrendBias = 1.0 + Math.random() * 1.5; // Random number between 1.0 and 2.5

        // Volatility factor - making it more dynamic
        const baseVolatility = (max - min) * 0.15; // 15% of the range

        // Randomly decide if this run should end at the maximum (or minimum for downward trend)
        const shouldEndAtMax = Math.random() < 0.3; // Lower the chance of hitting max/min at the end

        for (let i = 0; i < count; i++) {
            const progressFactor = i / (count - 1); // 0 at start, 1 at end

            // Dynamically adjust momentum based on trend direction and progress
            let momentum = isDownwardTrend
                ? Math.pow(1 - progressFactor, 0.5) * randomTrendBias * -1 // Downward momentum, stronger at start
                : Math.pow(progressFactor, 0.5) * randomTrendBias; // Upward momentum, stronger at end

            const randomDirectionChange = (Math.random() * 2 - 1); // Between -1 and 1

            let trendComponent = (randomDirectionChange + momentum) * baseVolatility;

            // Adjust trend behavior near boundaries (Allowing it to fall after hitting max)
            const rangeFactor = (currentValue - min) / (max - min); // 0 when at min, 1 when at max

            if (isDownwardTrend) {
                // If trending downwards, reduce downward push as it approaches min
                if (rangeFactor < 0.3) {
                    trendComponent *= rangeFactor; // Reduce downward push, increase volatility's impact
                }
            }
            else {
                // If trending upwards, and close to or at max, introduce a downward bias
                if (rangeFactor > 0.95) { // If within 5% of the max
                    trendComponent -= baseVolatility * (0.5 + Math.random() * 0.5); // Add a stronger push downwards, random factor for variability
                }
                else if (rangeFactor > 0.7) { // If in the upper 30% of the range
                    trendComponent *= (1 - rangeFactor); // Reduce upward push
                }
            }

            currentValue += trendComponent;

            // Apply volatility directly to currentValue to add more swing
            const fluctuation = (Math.random() * 2 - 1) * baseVolatility * (1 + Math.random());
            currentValue += fluctuation;

            // Constrain the value within the specified min and max bounds
            currentValue = Math.max(min, Math.min(max, currentValue));

            data.push(currentValue);

            // If it's the last element AND we decided this run should end at max (or min for downward), force it
            if (i === count - 1 && shouldEndAtMax) {
                data[i] = isDownwardTrend ? min : max;
            }
        }

        return data;
    }

    // #endregion Functions

    // #region Event Handlers

    function onRandomizeDataClicked(): void {
        series.value = generateSeries();
    }

    // #endregion Event Handlers

    // #region Watchers

    // watch([isUnfilled], () => {
    //     series.value = Enumerable
    //         .from(series.value)
    //         .select<LineSeries>((s) => {
    //             return {
    //                 ...s,
    //                 isUnfilled: isUnfilled.value
    //             };
    //         })
    //         .toArray();
    // });

    // watch(isLinear, () => {
    //     series.value = Enumerable
    //         .from(series.value)
    //         .select<LineSeries>(s => {
    //             return {
    //                 ...s,
    //                 isLinear: isLinear.value
    //             };
    //         })
    //         .toArray();
    // });

    watch(seriesCount, (newCount, oldCount) => {
        const amountToRemove = oldCount - newCount;

        if (amountToRemove > 0) {
            series.value = series.value.slice(0, newCount);
        }
        else {
            const amountToAdd = newCount - oldCount;

            if (amountToAdd > 0) {
                series.value = [
                    ...series.value,
                    generateOneSeries(newCount - 1)
                ];
            }
        }
    });

    watch([minValue, maxValue], () => {
        const min = Math.min(minValue.value, maxValue.value);
        const max = Math.max(minValue.value, maxValue.value);
        series.value = Enumerable
            .from(series.value)
            .select(s => {
                return {
                    ...s,
                    data: generateTrendingRandomData(labels.length, min, max, true)
                };
            })
            .toArray();
    });

    // watch(lineStyle, (newValue) => {
    //     series.value = Enumerable
    //         .from(series.value)
    //         .select<LineSeries>(s => {
    //             return {
    //                 ...s,
    //                 lineStyle: newValue
    //             };
    //         })
    //         .toArray();
    // });

    watch(isPercent, (newValue) => {
        if (newValue) {
            series.value = Enumerable
                .from(series.value)
                .select(s => {
                    return {
                        ...s,
                        data: Enumerable.from(s.data).select(n => typeof n === "number" ? n / 100 : n).toArray()
                    };
                })
                .toArray();
        }
        else {
            series.value = Enumerable
                .from(series.value)
                .select(s => {
                    return {
                        ...s,
                        data: Enumerable.from(s.data).select(n => typeof n === "number" ? n * 100 : n).toArray()
                    };
                })
                .toArray();
        }
    });

    // #endregion Watchers
</script>
