<template>
    <GalleryAndResult :value="{ series: series, labels: labels }" hasMultipleValues :importCode="importCode" :exampleCode="exampleCode">

        <div style="height: 300px">
            <BarChart :labels="labels"
                      :series="series"
                      :barLabels="barLabels"
                      :categoryLabel="categoryLabel"
                      :categoryMaxTickCount="categoryMaxTickCount"
                      :categoryShowAllTicks="categoryShowAllTicks"
                      :categoryShowGridLines="categoryShowGridLines"
                      :hideLegend="isLegendHidden"
                      :horizontal="isHorizontal"
                      :labelDateFormat="labelDateFormat"
                      :legendAlign="legendAlign"
                      :legendPosition="legendPosition"
                      :overlap="isOverlapped"
                      :stack="isStacked"
                      :title="title"
                      :tooltip="tooltip"
                      :tooltipTitle="tooltipTitle"
                      :type="isPercent ? 'percent' : isPercent === false ? 'number' : undefined"
                      :unfilled="isUnfilled"
                      :valueHideGridLines="valueHideGridLines"
                      :valueLabel="valueLabel"
                      :valueMaxTickCount="valueMaxTickCount"
                      :valueSuggestedMax="valueSuggestedMax"
                      :valueSuggestedMin="valueSuggestedMin"
                      :valueTickCount="valueTickCount"
                      @click="onBarChartClicked" />
        </div>

        <template #settings>
            <div class="settings">
                <ContentSection title="Settings">
                    <ContentStack title="General">
                        <div class="autolayout">
                            <TextBox :modelValue="title ?? ''"
                                     label="Chart Title"
                                     @update:modelValue="title = $event" />
                        </div>
                        <div class="autolayout">
                            <TextBox :modelValue="height ?? ''"
                                     label="Chart Container Height"
                                     help="CSS size value (e.g., '300px' or '50%')."
                                     @update:modelValue="height = $event" />
                            <TextBox :modelValue="width ?? ''"
                                     label="Chart Container Width"
                                     help="CSS size value (e.g., '300px' or '50%')."
                                     @update:modelValue="width = $event" />
                        </div>
                    </ContentStack>

                    <ContentStack title="Data">
                        <div class="autolayout">
                            <NumberUpDown v-model="seriesCount"
                                          label="Series Count"
                                          :min="1"
                                          :max="8" />

                            <DropDownList :modelValue="labelDateFormat ?? ''"
                                          help="If specified, then the labels array must have ISO 8601-formatted dates. If not specified, the labels will be treated as simple strings."
                                          :items="labelDateFormatItems"
                                          label="Label Date Format"
                                          @update:modelValue="labelDateFormat = <LabelDateFormat>$event" />

                            <Switch :modelValue="isPercent ?? false"
                                    help="For 'percent', the data must be in decimal form (e.g., 0.1 for 10%)."
                                    label="Percent"
                                    @update:modelValue="isPercent = $event" />

                            <Switch :modelValue="isStacked ?? false"
                                    help="Stack bars from different series on top of each other instead of side-by-side or overlapping."
                                    label="Stack"
                                    @update:modelValue="isStacked = $event" />

                            <Switch :modelValue="isOverlapped ?? false"
                                    help="Show bars from different series over each other instead of side-by-side or stacked. The 'unfilled' option is recommended to ensure visibility of overlapping data points."
                                    label="Overlap"
                                    @update:modelValue="isOverlapped = $event" />

                            <Switch :modelValue="isUnfilled ?? false"
                                    help="Unfilled bars are not filled with color, which could be useful to ensure visibility of overlapping data points when using 'overlap'."
                                    label="Unfilled"
                                    @update:modelValue="isUnfilled = $event" />

                            <Switch :modelValue="hasOutsideBarLabels ?? false"
                                    help="If labels overlap, those with a higher data index will be hidden. The chart height will also increase to fit the highest label."
                                    label="Outside Bar Labels"
                                    @update:modelValue="hasOutsideBarLabels = $event" />

                            <Switch :modelValue="hasInsideBarLabels ?? false"
                                    label="Inside Bar Labels"
                                    @update:modelValue="hasInsideBarLabels = $event" />

                            <Switch :modelValue="hasCustomTooltip ?? false"
                                    label="Custom Tooltip"
                                    @update:modelValue="hasCustomTooltip = $event" />

                            <Switch :modelValue="isHorizontal ?? false"
                                    label="Horizontal"
                                    @update:modelValue="isHorizontal = $event" />
                        </div>

                        <div class="autolayout">
                            <div class="button-wrapper">
                                <RockButton btnType="primary"
                                            @click="onRandomizeDataClicked">Randomize Data</RockButton>
                            </div>

                            <div class="button-wrapper">
                                <RockButton btnType="primary"
                                            @click="onRandomizeOpacityClicked">Randomize Opacity</RockButton>
                            </div>
                        </div>
                    </ContentStack>

                    <ContentStack title="Legend">
                        <div class="autolayout">
                            <DropDownList :modelValue="legendPosition ?? ''"
                                          :items="legendPositionItems"
                                          label="Position"
                                          @update:modelValue="legendPosition = <LegendPosition>$event" />

                            <DropDownList :modelValue="legendAlign ?? ''"
                                          :items="legendAlignItems"
                                          label="Alignment"
                                          @update:modelValue="legendAlign = <LegendAlign>$event" />

                            <Switch :modelValue="isLegendHidden ?? false"
                                    label="Hide"
                                    @update:modelValue="isLegendHidden = $event" />
                        </div>
                    </ContentStack>

                    <ContentStack title="Category Axis"
                                  :description="!isHorizontal ? '(x-axis)' : '(y-axis)'">
                        <div class="autolayout">
                            <TextBox :modelValue="categoryLabel ?? ''"
                                     label="Label"
                                     @update:modelValue="categoryLabel = $event" />

                            <NumberBox v-model="categoryMaxTickCount"
                                       label="Max Tick Count" />

                            <Switch :modelValue="categoryShowAllTicks ?? false"
                                    label="Show All Ticks"
                                    @update:modelValue="categoryShowAllTicks = $event" />

                            <Switch :modelValue="categoryShowGridLines ?? false"
                                    label="Show Grid Lines"
                                    @update:modelValue="categoryShowGridLines = $event" />
                        </div>
                    </ContentStack>

                    <ContentStack title="Value Axis"
                                  :description="!isHorizontal ? '(y-axis)' : '(x-axis)'">
                        <div class="autolayout">
                            <TextBox :modelValue="valueLabel ?? ''"
                                     label="Label"
                                     @update:modelValue="valueLabel = $event" />

                            <NumberBox v-model="valueTickCount"
                                       label="Tick Count" />

                            <NumberBox v-model="valueMaxTickCount"
                                       label="Max Tick Count" />

                            <NumberBox v-model="valueSuggestedMin"
                                       label="Suggested Min" />

                            <NumberBox v-model="valueSuggestedMax"
                                       label="Suggested Max" />

                            <Switch :modelValue="valueHideGridLines ?? false"
                                    label="Hide Grid Lines"
                                    @update:modelValue="valueHideGridLines = $event" />
                        </div>
                    </ContentStack>
                </ContentSection>
            </div>
        </template>
    </GalleryAndResult>
</template>

<style scoped>
.button-wrapper {
    display: flex;
    align-items: center;
}

.settings {
    max-height: 350px;
    overflow: auto;
}

.autolayout {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    column-gap: var(--spacing-small);
}
</style>

<script setup lang="ts">
    import { computed, ref, watch } from "vue";
    import GalleryAndResult from "./common/galleryAndResult.partial.obs";
    import { getSfcControlImportPath } from "./common/utils.partial";
    import ContentSection from "@Obsidian/Controls/contentSection.obs";
    import ContentStack from "@Obsidian/Controls/contentStack.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import BarChart from "@Obsidian/Controls/barChart.obs";
    import NumberBox from "@Obsidian/Controls/numberBox.obs";
    import NumberUpDown from "@Obsidian/Controls/numberUpDown.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import Switch from "@Obsidian/Controls/switch.obs";
    import TextBox from "@Obsidian/Controls/textBox.obs";
    import { BarSeries, LabelDateFormat, LegendAlign, LegendPosition, LabelDateFormatDescription, LegendAlignDescription, LegendPositionDescription, BarChartClickEvent, BarLabelContext, BarLabelsConfig, TooltipCallback } from "@Obsidian/Core/Controls/chart";
    import { Enumerable } from "@Obsidian/Utility/linq";
    import { isNullish } from "@Obsidian/Utility/util";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";

    const importCode = getSfcControlImportPath("barChart");
    const legendPositionItems = [
        { text: LegendPositionDescription[LegendPosition.Top], value: LegendPosition.Top },
        { text: LegendPositionDescription[LegendPosition.Bottom], value: LegendPosition.Bottom },
        { text: LegendPositionDescription[LegendPosition.Left], value: LegendPosition.Left },
        { text: LegendPositionDescription[LegendPosition.Right], value: LegendPosition.Right }
    ];
    const legendAlignItems = [
        { text: LegendAlignDescription[LegendAlign.Start], value: LegendAlign.Start },
        { text: LegendAlignDescription[LegendAlign.Center], value: LegendAlign.Center },
        { text: LegendAlignDescription[LegendAlign.End], value: LegendAlign.End }
    ];
    const labelDateFormatItems = [
        { text: LabelDateFormatDescription[LabelDateFormat.Auto], value: LabelDateFormat.Auto },
        { text: LabelDateFormatDescription[LabelDateFormat.Day], value: LabelDateFormat.Day },
        { text: LabelDateFormatDescription[LabelDateFormat.Week], value: LabelDateFormat.Week },
        { text: LabelDateFormatDescription[LabelDateFormat.Month], value: LabelDateFormat.Month },
        { text: LabelDateFormatDescription[LabelDateFormat.Year], value: LabelDateFormat.Year }
    ];
    const labels = [
        "2024-12-01T00:00:00",
        "2025-01-01T00:00:00",
        "2025-02-01T00:00:00"
    ];

    // #region Values

    const series = ref<BarSeries[]>([
        {
            label: "Small Group",
            data: [49, 73, 96],
        },
        {
            label: "Baptism",
            data: [11, 44, 47],
        }
    ]);
    const minValue = ref<number>(0);
    const maxValue = ref<number>(100);
    const categoryShowGridLines = ref<boolean | undefined>();
    const valueHideGridLines = ref<boolean | undefined>();
    const categoryMaxTickCount = ref<number | undefined>();
    const categoryShowAllTicks = ref<boolean | undefined>();
    const height = ref<string | undefined>();
    const width = ref<string | undefined>();
    const valueMaxTickCount = ref<number | undefined>();
    const isUnfilled = ref<boolean | undefined>();
    const isOverlapped = ref<boolean | undefined>();
    const isStacked = ref<boolean | undefined>();
    const seriesCount = ref<number>(series.value.length);
    const legendPosition = ref<LegendPosition | undefined>();
    const legendAlign = ref<LegendAlign | undefined>();
    const isLegendHidden = ref<boolean | undefined>();
    const isHorizontal = ref<boolean | undefined>();
    const labelDateFormat = ref<LabelDateFormat | undefined>(LabelDateFormat.Auto);
    const isPercent = ref<boolean | undefined>();
    const valueTickCount = ref<number | undefined>();
    const categoryLabel = ref<string | undefined>("Category Label");
    const valueLabel = ref<string | undefined>("Value Label");
    const title = ref<string | undefined>("Chart Title");
    const valueSuggestedMin = ref<number | undefined>();
    const valueSuggestedMax = ref<number | undefined>();
    const opacity = ref<number | number[] | undefined>();
    const hasOutsideBarLabels = ref<boolean | undefined>();
    const hasInsideBarLabels = ref<boolean | undefined>();
    const hasCustomTooltip = ref<boolean | undefined>();

    // #endregion Values

    // #region Computed Values

    const exampleCode = computed<string>(() => {
        let barChartProps: string[] = [
            `:labels="labels"`,
            `:series="series"`
        ];

        if (categoryLabel.value) {
            barChartProps.push(`categoryLabel="${categoryLabel.value}"`);
        }
        if (!isNullish(categoryMaxTickCount.value)) {
            barChartProps.push(`:categoryMaxTickCount="${categoryMaxTickCount.value}"`);
        }
        if (!isNullish(categoryShowAllTicks.value)) {
            barChartProps.push(`:categoryShowAllTicks="${categoryShowAllTicks.value}"`);
        }
        if (!isNullish(categoryShowGridLines.value)) {
            barChartProps.push(`:categoryShowGridLines="${categoryShowGridLines.value}"`);
        }
        if (!isNullish(height.value)) {
            barChartProps.push(`height="${height.value}"`);
        }
        if (!isNullish(width.value)) {
            barChartProps.push(`width="${width.value}"`);
        }
        if (!isNullish(isLegendHidden.value)) {
            barChartProps.push(`:hideLegend="${isLegendHidden.value}"`);
        }
        if (!isNullish(isHorizontal.value)) {
            barChartProps.push(`:horizontal="${isHorizontal.value}"`);
        }
        if (!isNullish(labelDateFormat.value)) {
            barChartProps.push(`labelDateFormat="${labelDateFormat.value}"`);
        }
        if (!isNullish(legendAlign.value)) {
            barChartProps.push(`legendAlign="${legendAlign.value}"`);
        }
        if (!isNullish(legendPosition.value)) {
            barChartProps.push(`legendPosition="${legendPosition.value}"`);
        }
        if (!isNullish(isOverlapped.value)) {
            barChartProps.push(`:overlap="${isOverlapped.value}"`);
        }
        if (!isNullish(isStacked.value)) {
            barChartProps.push(`:stack="${isStacked.value}"`);
        }
        if (title.value) {
            barChartProps.push(`title="${title.value}"`);
        }
        if (!isNullish(isPercent.value)) {
            if (isPercent.value) {
                barChartProps.push(`type="percent"`);
            }
            else {
                barChartProps.push(`type="number"`);
            }
        }
        if (!isNullish(isUnfilled.value)) {
            barChartProps.push(`":unfilled="${isUnfilled.value}"`);
        }
        if (!isNullish(valueHideGridLines.value)) {
            barChartProps.push(`:valueHideGridLines="${valueHideGridLines.value}"`);
        }
        if (valueLabel.value) {
            barChartProps.push(`valueLabel="${valueLabel.value}"`);
        }
        if (!isNullish(valueMaxTickCount.value)) {
            barChartProps.push(`:valueMaxTickCount="${valueMaxTickCount.value}"`);
        }
        if (!isNullish(valueSuggestedMax.value)) {
            barChartProps.push(`:valueSuggestedMax="${valueSuggestedMax.value}"`);
        }
        if (!isNullish(valueSuggestedMin.value)) {
            barChartProps.push(`:valueSuggestedMin="${valueSuggestedMin.value}"`);
        }
        if (!isNullish(valueTickCount.value)) {
            barChartProps.push(`:valueTickCount="${valueTickCount.value}"`);
        }

        const prefix = "<BarChart ";
        const spaces = " ".repeat(prefix.length);
        return `${prefix}${barChartProps.join(`\n${spaces}`)} />`;
    });

    const tooltip = computed<TooltipCallback | undefined>(() => {
        if (hasCustomTooltip.value) {
            return (ctx) => {
                if (isPercent.value) {
                    return `The ${ctx.seriesLabel} value for ${ctx.formattedLabel} is ${ctx.value?.toLocaleString(undefined, { style: "percent", maximumFractionDigits: 2 })}.`;
                }
                else {
                    return `The ${ctx.seriesLabel} value for ${ctx.formattedLabel} is ${ctx.value?.toLocaleString()}.`;
                }
            };
        }
    });

    const tooltipTitle = computed<TooltipCallback | undefined>(() => {
        if (hasCustomTooltip.value) {
            return (ctx) => {
                return RockDateTime.parseISO(ctx.label)?.toLocaleString({ dateStyle: "long" }) ?? ctx.formattedLabel;
            };
        }
    });

    // #endregion Computed Values

    // #region Functions

    function generateSeries(): BarSeries[] {
        return Enumerable
            .from(Array(seriesCount.value).keys())
            .select(i => generateOneSeries(i))
            .toArray();
    }

    function generateOneSeries(i: number): BarSeries {
        const min = Math.min(minValue.value, maxValue.value);
        const max = Math.max(minValue.value, maxValue.value);
        let data = generateRandomBarData(labels.length, min, max, true);

        if (isPercent.value) {
            data = Enumerable.from(data).select(n => typeof n === "number" ? n / 100 : n).toArray();
        }

        const s: BarSeries = {
            label: `Series ${i + 1}`,
            data: data,
            opacity: opacity.value
        };

        return s;
    }

    const barLabels = computed<BarLabelsConfig | undefined>(() => {
        if (hasInsideBarLabels.value || hasOutsideBarLabels.value) {
            return {
                outside: hasOutsideBarLabels.value ? {
                    formatter: (ctx: BarLabelContext): string => {
                        return ctx.seriesName;
                    },
                } : undefined,
                inside: hasInsideBarLabels.value ? {
                    formatter: (ctx: BarLabelContext): string => {
                        return ctx.formattedValue || ctx.value.toLocaleString(undefined, { maximumFractionDigits: 0 });
                    },
                } : undefined
            };
        }
    });

    /**
 * Generate independent random values between `min` and `max` for bar charts.
 * - No trend or momentum; each value is i.i.d.
 * - No accumulation across points.
 *
 * Note: `startAtMin` is ignored and kept only for backward compatibility.
 */
    function generateRandomBarData(
        count: number,
        min: number,
        max: number,
        _startAtMin: boolean = true
    ): number[] {
        if (count <= 0) return [];
        if (min > max) [min, max] = [max, min];

        const range = max - min;
        const data = new Array<number>(count);

        for (let i = 0; i < count; i++) {
            data[i] = min + Math.random() * range; // uniform in [min, max)
        }

        return data;
    }

    // #endregion Functions

    // #region Event Handlers

    function onRandomizeDataClicked(): void {
        series.value = generateSeries();
    }

    function onRandomizeOpacityClicked(): void {
        opacity.value = Enumerable
            .from(labels)
            .withIndex()
            .select(([_label, _index]) => (Math.random() > 0.5 ? 0.25 : 1))
            .toArray();
    }

    function onBarChartClicked(event: BarChartClickEvent): void {
        if (event.targets.length === 0) {
            // If no targets, reset opacity to full.
            opacity.value = 1;
            return;
        }

        const clickedLabelIndexes = Enumerable
            .from(event.targets)
            .select(t => t.labelIndex)
            .toArray();

        const newOpacity = Enumerable
            .from(labels)
            .withIndex()
            .select<number>(([_label, index]) => {
                if (clickedLabelIndexes.includes(index)) {
                    return 1;
                }
                return 0.25;
            })
            .toArray();

        // If the new and old opacities are the same,
        // then narrow down the opacity to the selected
        // dataset.
        if (Array.isArray(opacity.value) && Enumerable.from(newOpacity).sequenceEqual(opacity.value)) {
            opacity.value = undefined;
            series.value = Enumerable
                .from(series.value)
                .withIndex()
                .select<BarSeries>(([s, seriesIndex]) => {
                    const targetsWithThisSeries = Enumerable
                        .from(event.targets)
                        .where(t => t.seriesIndex === seriesIndex)
                        .toArray();

                    if (targetsWithThisSeries.length) {
                        const opacities = Enumerable
                            .from(labels)
                            .withIndex()
                            .select<number>(([_label, labelIndex]) => {
                                if (Enumerable.from(targetsWithThisSeries).any(t => t.labelIndex === labelIndex)) {
                                    return 1;
                                }
                                else {
                                    return 0.25;
                                }
                            })
                            .toArray();

                        return {
                            ...s,
                            opacity: opacities
                        };
                    }
                    return {
                        ...s,
                        opacity: 0.25 // This series was not selected.
                    };
                }).toArray();
        }
        else {
            // When an index/series is clicked, let's set the opacity of everything but the selected value
            // to semi-transparent.
            opacity.value = newOpacity;
        }
    }

    // #endregion Event Handlers

    // #region Watchers

    watch(seriesCount, (newCount, oldCount) => {
        const amountToRemove = oldCount - newCount;

        if (amountToRemove > 0) {
            series.value = series.value.slice(0, newCount);
        }
        else {
            const amountToAdd = newCount - oldCount;

            if (amountToAdd > 0) {
                series.value = [
                    ...series.value,
                    generateOneSeries(newCount - 1)
                ];
            }
        }
    });

    watch([minValue, maxValue], () => {
        const min = Math.min(minValue.value, maxValue.value);
        const max = Math.max(minValue.value, maxValue.value);
        series.value = Enumerable
            .from(series.value)
            .select(s => {
                return {
                    ...s,
                    data: generateRandomBarData(labels.length, min, max, true)
                };
            })
            .toArray();
    });

    watch(isPercent, (newValue) => {
        if (newValue) {
            series.value = Enumerable
                .from(series.value)
                .select(s => {
                    return {
                        ...s,
                        data: Enumerable.from(s.data).select(n => typeof n === "number" ? n / 100 : n).toArray()
                    };
                })
                .toArray();
        }
        else {
            series.value = Enumerable
                .from(series.value)
                .select(s => {
                    return {
                        ...s,
                        data: Enumerable.from(s.data).select(n => typeof n === "number" ? n * 100 : n).toArray()
                    };
                })
                .toArray();
        }
    });

    watch(opacity, (opacity) => {
        if (!isNullish(opacity)) {
            series.value = Enumerable
                .from(series.value)
                .select(s => {
                    return {
                        ...s,
                        opacity: opacity
                    };
                })
                .toArray();
        }
    });

    // #endregion Watchers
</script>
