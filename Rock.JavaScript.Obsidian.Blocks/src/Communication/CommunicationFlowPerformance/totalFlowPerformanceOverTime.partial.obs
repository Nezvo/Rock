<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Panel v-if="hasSentCommunications"
           hasFullscreen
           panelBodyCssClass="chart-container"
           title="Total Flow Performance Over Time">
        <LineChart :modelValue="dataPoints"
                   :axes="{
                    label: { type: labelType },
                    value: {
                        type: 'percent',
                        maxDecimalPlaces: 2,
                        limits: { min: 0 }
                    }
                }"
                   :legend="{
                    position: 'top'
                }"
                   :seriesSort="[SeriesName.ConversionRate, SeriesName.UnsubscribeRate]" />
    </Panel>

    <NothingToShow v-else title="Total Flow Performance Over Time" />
</template>

<style scoped>
:deep(.chart-container) {
    height: 265px;
}
</style>

<script setup lang="ts">
    /* eslint-disable @typescript-eslint/naming-convention */
    import { computed, PropType } from "vue";
    import NothingToShow from "./nothingToShow.partial.obs";
    import { isRockDateTime, useRockDateTimeParser } from "./utils.partial";
    import LineChart from "@Obsidian/Controls/lineChart.obs";
    import Panel from "@Obsidian/Controls/panel.obs";
    import { buildCumulativeRates } from "@Obsidian/Utility/chartUtils";
    import { Enumerable } from "@Obsidian/Utility/linq";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { ChartNumericDataPointBag } from "@Obsidian/ViewModels/Reporting/chartNumericDataPointBag";
    import { MessageBag } from "@Obsidian/ViewModels/Blocks/Communication/CommunicationFlowPerformance/messageBag";
    import { isNullish } from "@Obsidian/Utility/util";

    /**
     * In terms of metrics, the percentage of PEOPLE who achieved the conversion goal is most important,
     * not the individual conversion events.
     */

    const { parseRockDateTime } = useRockDateTimeParser();

    enum SeriesName {
        ConversionRate = "Conversion Rate",
        UnsubscribeRate = "Unsubscribe Rate"
    }

    const props = defineProps({
        messages: {
            type: Array as PropType<MessageBag[]>,
            required: true
        },

        dateUnit: {
            type: String as PropType<"day" | "month" | "week">,
            required: true
        },

        uniquePersonCount: {
            type: Number as PropType<number>,
            required: true
        }
    });

    // #region Computed Values

    const hasSentCommunications = computed<boolean>(() => {
        // Check if there are any recipients with a sent date.
        return Enumerable.from(props.messages).any(m => !!m.sentDateTime);
    });

    const labelType = computed<"date.day" | "date.week" | "date.month">(() => {
        return props.dateUnit === "day"
            ? "date.day"
            : props.dateUnit === "week"
                ? "date.week"
                : "date.month";
    });

    const dateFormatter = computed<(d: RockDateTime) => string>(() => {
        return (d: RockDateTime) => {
            return d.toASPString("yyyy-MM-dd");
        };
    });

    const dateTransformer = computed<(d: RockDateTime) => RockDateTime>(() => {
        return (d: RockDateTime) => {
            switch (props.dateUnit) {
                case "week":
                    return d.startOfWeek();
                case "month":
                    return d.startOfMonth();
                case "day":
                default:
                    return d;
            }
        };
    });

    const dataPoints = computed<ChartNumericDataPointBag[]>(() => {
        const messageCount = Enumerable.from(props.messages).count();

        if (messageCount <= 0) {
            return [];
        }
        const messageEnumerable = Enumerable.from(props.messages).where(m => !isNullish(m.personAliasIdKey));

        const conversionRateDataPoints = buildCumulativeRates(
            // Conversion dates.
            // Get the first conversion date for each person.
            // This ensures that if a person has multiple conversion events,
            // they are only counted once since this metric is about people, not events.
            messageEnumerable
                .groupBy(m => m.personAliasIdKey!)
                .select(g => g
                    .select(m => parseRockDateTime(m.convertedDateTime))
                    .firstOrDefault())
                .ofType(isRockDateTime),
            {
                seriesName: SeriesName.ConversionRate,
                color: "#68D391",
                totalCount: props.uniquePersonCount,
                dateTransformer: dateTransformer.value,
                dateFormatter: dateFormatter.value
            }
        );

        const unsubscribeRateDataPoints = buildCumulativeRates(
            // Unsubscribe dates.
            // Get all unsubscribe dates for each person.
            messageEnumerable
                .select(m => parseRockDateTime(m.unsubscribedDateTime))
                .ofType(isRockDateTime),
            {
                seriesName: SeriesName.UnsubscribeRate,
                color: "#FC8181",
                totalCount: messageCount,
                dateTransformer: dateTransformer.value,
                dateFormatter: dateFormatter.value
            });

        const dataPoints = conversionRateDataPoints
            .concat(unsubscribeRateDataPoints)
            .orderBy(d => d.rockDateTime.toMilliseconds()) // Re-order so the data are all in chronological order.
            .toArray();

        // Ensure the data points include the earliest instance start date.
        const earliestInstanceSentDate = messageEnumerable
            .select(m => parseRockDateTime(m.communicationFlowInstanceStartDate))
            .ofType(isRockDateTime)
            .orderBy(d => d.toMilliseconds())
            .select(d => dateTransformer.value(d))
            .firstOrDefault();

        if (earliestInstanceSentDate && !dataPoints.some(d => d.rockDateTime.isEarlierThan(earliestInstanceSentDate))) {
            dataPoints.unshift({
                rockDateTime: earliestInstanceSentDate,
                seriesName: SeriesName.ConversionRate,
                color: "#68D391",
                value: 0,
                label: dateFormatter.value(earliestInstanceSentDate)
            });
        }

        return dataPoints;
    });

    // #endregion Computed Values
</script>