<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <div v-if="newChartData" class="communication-detail-unique-interactions-over-time">
        <div class="communication-detail-unique-interactions-over-time-actions">
            <RadioButtonList v-if="showPerformanceChartTimeframeFilter"
                             v-model="performanceChartTimeframe"
                             :items="performanceChartTimeframeItems"
                             :horizontal="true"
                             :disableLabel="true" />
        </div>
        <div class="communication-detail-unique-interactions-over-time-chart">
            <LineChart title="Unique Interactions Over Time"
                       :labels="newLabels"
                       :series="newSeries"
                       :categoryShowGridLines="true"
                       :legendAlign="LegendAlign.Start"
                       :legendPosition="LegendPosition.Bottom"
                       :lineStyle="LineStyle.Solid"
                       :unfilled="true"
                       type="percent" />
        </div>
    </div>
</template>

<style scoped>
.communication-detail-unique-interactions-over-time {
    height: 100%;
    display: flex;
    flex-direction: column;
}

.communication-detail-unique-interactions-over-time-actions {
    flex: 0 0 auto;
}

.communication-detail-unique-interactions-over-time-chart {
    flex: 1 0 auto;
}
</style>

<script setup lang="ts">
    import { computed, PropType, ref } from "vue";
    import { useCommunicationDetail } from "./utils.partial";
    import LineChart from "@Obsidian/Controls/lineChart.obs";
    import RadioButtonList from "@Obsidian/Controls/radioButtonList.obs";
    import { LegendAlign, LegendPosition, LineSeries, LineStyle } from "@Obsidian/Core/Controls/chart";
    import { getCssVariableValue } from "@Obsidian/Utility/cssUtils";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { isNullish } from "@Obsidian/Utility/util";
    import { ChartNumericDataPointBag } from "@Obsidian/ViewModels/Reporting/chartNumericDataPointBag";

    const communicationDetail = useCommunicationDetail();

    const enum PerformanceChartTimeframe {
        First45Days = "First 45 Days",
        AllTime = "All Time"
    }

    const performanceChartTimeframeItems = [
        {
            text: PerformanceChartTimeframe.First45Days,
            value: PerformanceChartTimeframe.First45Days
        },
        {
            text: PerformanceChartTimeframe.AllTime,
            value: PerformanceChartTimeframe.AllTime
        }
    ];

    const props = defineProps({
        chartDataPoints: {
            type: Array as PropType<ChartNumericDataPointBag[] | null | undefined>,
            required: true
        }
    });

    type InteractionDataPoint = ChartNumericDataPointBag & { date: RockDateTime };

    // #region Values

    const performanceChartTimeframe = ref(PerformanceChartTimeframe.First45Days);

    // #endregion Values

    // #region Computed Values

    const communicationSendDate = computed((): RockDateTime | undefined => {
        return communicationDetail.value?.sendDateTime
            ? RockDateTime.parseISO(communicationDetail.value.sendDateTime)?.date
            : undefined;
    });

    const fortyFifthDayDate = computed((): RockDateTime | undefined => {
        return communicationSendDate.value?.addDays(44);
    });

    const dataPoints = computed((): InteractionDataPoint[] => {
        if (!props.chartDataPoints || !communicationSendDate.value) {
            return [];
        }

        // Enrich each data point with the parsed RockDateTime.
        return props.chartDataPoints
            .filter(dp =>
                dp?.seriesName
                && dp.label
                && !isNullish(dp.value)
                && dp.color
            )
            .map(dp => {
                const date = RockDateTime.parseISO(dp.label!);
                if (!date) {
                    return null;
                }
                return { ...dp, date };
            })
            .filter((dp): dp is InteractionDataPoint => !!dp);
    });

    const showPerformanceChartTimeframeFilter = computed((): boolean => {
        return !!(
            fortyFifthDayDate.value
            && dataPoints.value
                .some(dp => dp.date > fortyFifthDayDate.value!)
        );
    });

    const visibleDataPoints = computed((): ChartNumericDataPointBag[] => {
        return dataPoints.value
            .filter(dp => {
                if (performanceChartTimeframe.value === PerformanceChartTimeframe.AllTime) {
                    return true;
                }

                // Only show data points for the first 45 days.
                return dp.date <= fortyFifthDayDate.value!;
            })
            .map(dp => ({
                ...dp,
                label: dp.date.toASPString("d")
            }));
    });

    const newChartData = computed<{ labels: string[]; series: LineSeries[] } | null>(() => {
        if (!visibleDataPoints.value.length) {
            return null;
        }

        // The server returns a flat, ordered list of data points, with a
        // guarantee that each series has data for each label. We'll transform
        // this data into the structure expected by the LineChart component.
        const labels = new Set<string>();
        const seriesDataSets = new Map<string, LineSeries>();

        visibleDataPoints.value.forEach(dp => {
            const seriesName = dp.seriesName!;
            let seriesDataSet = seriesDataSets.get(seriesName);

            const color = getCssVariableValue(dp.color!, "#8B8BA7");

            if (!seriesDataSet) {
                seriesDataSet = {
                    label: dp.seriesName!,
                    data: [],
                    color: color,
                };

                seriesDataSets.set(seriesName, seriesDataSet);
            }

            labels.add(dp.label!);
            seriesDataSet.data.push(dp.value! / 100);
        });

        return {
            labels: Array.from(labels),
            series: Array.from(seriesDataSets.values())
        };
    });

    const newLabels = computed((): string[] => {
        return newChartData.value ? newChartData.value.labels : [];
    });

    const newSeries = computed((): LineSeries[] => {
        return newChartData.value ? newChartData.value.series : [];
    });

    // #endregion Computed Values
</script>
