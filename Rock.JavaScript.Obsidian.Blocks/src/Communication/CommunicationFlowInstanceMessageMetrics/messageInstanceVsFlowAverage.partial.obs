<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Panel v-if="hasSentCommunications"
           panelBodyCssClass="chart-container"
           title="Message Instance vs. Flow Average">
        <BarChart :series="data.series"
                  :labels="data.labels"
                  :barLabels="barLabels"
                  hideLegend
                  type="percent" />
    </Panel>

    <NothingToShowPartial v-else title="Message Instance vs. Flow Average" />
</template>

<style scoped>
:deep(.chart-container) {
    height: 265px;
}
</style>

<script setup lang="ts">
    import { computed, PropType } from "vue";
    import NothingToShowPartial from "./nothingToShow.partial.obs";
    import BarChart from "@Obsidian/Controls/barChart.obs";
    import Panel from "@Obsidian/Controls/panel.obs";
    import { BarLabelsConfig, BarSeries } from "@Obsidian/Core/Controls/chart";
    import { Enumerable } from "@Obsidian/Utility/linq";
    import { isNullish } from "@Obsidian/Utility/util";
    import { CommunicationFlowInstanceBag } from "@Obsidian/ViewModels/Blocks/Communication/CommunicationFlowInstanceMessageMetrics/communicationFlowInstanceBag";
    import { CommunicationFlowInstanceCommunicationBag } from "@Obsidian/ViewModels/Blocks/Communication/CommunicationFlowInstanceMessageMetrics/communicationFlowInstanceCommunicationBag";
    import { RecipientMetricsBag } from "@Obsidian/ViewModels/Blocks/Communication/CommunicationFlowInstanceMessageMetrics/recipientMetricsBag";

    /**
     *  Purpose: "How does this instance of this message compare across all instances of this flow?"
     */

    enum SeriesName {
        Instance = "Instance",
        Average = "Average"
    }

    type Metrics = {
        peopleConverted: number;
        peopleUnsubscribed: number;
        peopleOpened: number;
        peopleClicked: number;
        uniquePersonCount: number;
    };

    const props = defineProps({
        allCommunicationFlowInstanceCommunications: {
            type: Array as PropType<CommunicationFlowInstanceCommunicationBag[]>,
            required: true
        },

        allCommunicationFlowInstances: {
            type: Array as PropType<CommunicationFlowInstanceBag[]>,
            required: true
        },

        allUniquePersonCount: {
            type: Number as PropType<number>,
            required: true
        },

        isConversionGoalTrackingEnabled: {
            type: Boolean as PropType<boolean>,
            required: true
        },

        selectedCommunicationFlowInstanceRecipientMetrics: {
            type: Array as PropType<RecipientMetricsBag[]>,
            required: true
        }
    });

    // #region Computed Values

    const barLabels = computed<BarLabelsConfig>(() => {
        return {
            inside: {
                formatter: ({ formattedValue, value }) => {
                    return formattedValue ?? value.toLocaleString(undefined, { style: "percent", maximumFractionDigits: 0 });
                }
            },
            outside: {
                formatter: ({ seriesName }) => seriesName
            }
        };
    });

    const hasSentCommunications = computed<boolean>(() => {
        // Check if there are any recipients with a sent date.
        return Enumerable.from(props.selectedCommunicationFlowInstanceRecipientMetrics).any(m => !!m.sentDate)
            && data.value.labels.length > 0;
    });

    const selectedCommunicationFlowInstanceRecipientMetrics = computed<Metrics>(() => {
        const selectedCommunicationFlowInstanceRecipientMetrics = Enumerable
            .from(props.selectedCommunicationFlowInstanceRecipientMetrics)
            .groupBy(rm => rm.personAliasIdKey)
            .toArray();

        const selectedMetrics: Metrics = {
            peopleConverted: Enumerable
                .from(selectedCommunicationFlowInstanceRecipientMetrics)
                .count(g => g.any(rm => !isNullish(rm.conversionDate))),
            peopleOpened: Enumerable
                .from(selectedCommunicationFlowInstanceRecipientMetrics)
                .count(g => g.any(rm => !isNullish(rm.openedDate))),
            peopleClicked: Enumerable
                .from(selectedCommunicationFlowInstanceRecipientMetrics)
                .count(g => g.any(rm => !isNullish(rm.clickedDate))),
            peopleUnsubscribed: Enumerable
                .from(selectedCommunicationFlowInstanceRecipientMetrics)
                .count(g => g.any(rm => !isNullish(rm.unsubscribeDate))),
            uniquePersonCount: Enumerable.from(selectedCommunicationFlowInstanceRecipientMetrics.keys()).count()
        };

        return selectedMetrics;
    });

    const allCommunicationFlowInstanceRecipientMetrics = computed<Metrics>(() => {
        const allCommunicationFlowInstanceRecipientMetrics = Enumerable
            .from(props.allCommunicationFlowInstanceCommunications)
            .selectMany(cfic => cfic.recipientMetrics ?? [])
            .groupBy(rm => rm.personAliasIdKey)
            .toArray();

        const allMetrics: Metrics = {
            peopleConverted: Enumerable
                .from(allCommunicationFlowInstanceRecipientMetrics)
                .count(g => g.any(rm => !isNullish(rm.conversionDate))),
            peopleOpened: Enumerable
                .from(allCommunicationFlowInstanceRecipientMetrics)
                .count(g => g.any(rm => !isNullish(rm.openedDate))),
            peopleClicked: Enumerable
                .from(allCommunicationFlowInstanceRecipientMetrics)
                .count(g => g.any(rm => !isNullish(rm.clickedDate))),
            peopleUnsubscribed: Enumerable
                .from(allCommunicationFlowInstanceRecipientMetrics)
                .count(g => g.any(rm => !isNullish(rm.unsubscribeDate))),
            uniquePersonCount: Enumerable.from(allCommunicationFlowInstanceRecipientMetrics.keys()).count()
        };

        return allMetrics;
    });

    const data = computed<{ series: BarSeries[]; labels: string[]; }>(() => {
        const { peopleConverted: allPeopleConverted, peopleOpened: allPeopleOpened, peopleClicked: allPeopleClicked, peopleUnsubscribed: allPeopleUnsubscribed, uniquePersonCount: allUniquePersonCount } = allCommunicationFlowInstanceRecipientMetrics.value;

        const averageConversionRate = allUniquePersonCount
            ? allPeopleConverted / allUniquePersonCount
            : 0;
        const averageOpenRate = allUniquePersonCount ? allPeopleOpened / allUniquePersonCount : 0;
        const averageClickRate = allUniquePersonCount ? allPeopleClicked / allUniquePersonCount : 0;
        const averageUnsubscribeRate = allUniquePersonCount ? allPeopleUnsubscribed / allUniquePersonCount : 0;

        const { peopleConverted: selectedPeopleConverted, peopleOpened: selectedPeopleOpened, peopleClicked: selectedPeopleClicked, peopleUnsubscribed: selectedPeopleUnsubscribed, uniquePersonCount: selectedUniquePersonCount } = selectedCommunicationFlowInstanceRecipientMetrics.value;

        const hasConversionRates = averageConversionRate > 0 || selectedPeopleConverted > 0;
        const hasOpenRates = averageOpenRate > 0 || selectedPeopleOpened > 0;
        const hasClickRates = averageClickRate > 0 || selectedPeopleClicked > 0;
        const hasUnsubscribeRates = averageUnsubscribeRate > 0 || selectedPeopleUnsubscribed > 0;

        const labels: string[] = [];
        if (props.isConversionGoalTrackingEnabled && hasConversionRates) {
            labels.push("Conversion Rate");
        }
        if (hasOpenRates) {
            labels.push("Open Rate");
        }
        if (hasClickRates) {
            labels.push("Click-Through Rate");
        }
        if (hasUnsubscribeRates) {
            labels.push("Unsubscribe Rate");
        }

        const instanceColors: string[] = [];

        const instanceSeries: BarSeries = {
            label: SeriesName.Instance,
            data: [],
            color: instanceColors
        };

        if (props.isConversionGoalTrackingEnabled && hasConversionRates) {
            instanceSeries.data.push(selectedUniquePersonCount ? selectedPeopleConverted / selectedUniquePersonCount : 0);
            instanceColors.push("#2F855A");
        }
        if (hasOpenRates) {
            instanceSeries.data.push(selectedUniquePersonCount ? selectedPeopleOpened / selectedUniquePersonCount : 0);
            instanceColors.push("#3182CE");
        }
        if (hasClickRates) {
            instanceSeries.data.push(selectedUniquePersonCount ? selectedPeopleClicked / selectedUniquePersonCount : 0);
            instanceColors.push("#DD6B20");
        }
        if (hasUnsubscribeRates) {
            instanceSeries.data.push(selectedUniquePersonCount ? selectedPeopleUnsubscribed / selectedUniquePersonCount : 0);
            instanceColors.push("#C53030");
        }

        const averageColors: string[] = [];
        const averageSeries: BarSeries = {
            label: SeriesName.Average,
            data: [],
            color: averageColors
        };

        if (props.isConversionGoalTrackingEnabled && hasConversionRates) {
            averageSeries.data.push(averageConversionRate);
            averageColors.push("#9AE6B4");
        }
        if (hasOpenRates) {
            averageSeries.data.push(averageOpenRate);
            averageColors.push("#90CDF4");
        }
        if (hasClickRates) {
            averageSeries.data.push(averageClickRate);
            averageColors.push("#FBD38D");
        }
        if (hasUnsubscribeRates) {
            averageSeries.data.push(averageUnsubscribeRate);
            averageColors.push("#FEB2B2");
        }

        return {
            labels,
            series: [instanceSeries, averageSeries]
        };
    });

    // #endregion Computed Values
</script>
