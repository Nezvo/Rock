<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <ContentSectionContainer :sidebar="false">
        <ContentSection light>
            <ContentStack>
                <div class="row">
                    <div class="col-md-6">
                        <TextBox v-model="name"
                                 label="Name"
                                 rules="required" />
                    </div>
                    <div class="col-md-6">
                        <CheckBox v-model="isActive"
                                  label="Active" />
                    </div>
                </div>

                <TextBox v-model="description"
                         label="Description"
                         textMode="multiline" />

                <div class="row">
                    <div class="col-md-3">
                        <ColorPicker v-model="highlightColor"
                                     label="Highlight Color"
                                     help="The color to use when displaying steps of this type." />
                    </div>
                </div>
                <div class="row">
                    <div class="col-md-3">
                        <IconPicker v-model="iconCssClass"
                                    label="Icon" />
                    </div>
                </div>
                <div class="row">
                    <div class="col-md-3">
                        <InlineCheckBox v-model="showCountOnBadge"
                                        label="Show Count on Badge"
                                        help="Determines if the count of the number of times a step has been completed should be shown on the badge for the person profile page." />
                    </div>
                </div>
            </ContentStack>
        </ContentSection>

        <ContentSection title="General Settings" icon="ti ti-adjustments-cog">
            <ContentStack title="Step Configuration" description="Define the type and purpose of this step, and specify if any other steps must be completed first.">
                <RadioButtonList label="Engagement Type"
                                 v-model="engagementType"
                                 :help="engagementTypeHelpText"
                                 :items="engagementTypes" />
                <RadioButtonList label="Organizational Objective"
                                 v-model="organizationalObjectiveValue"
                                 help="Describes the main focus of the step and how it supports the organization's mission."
                                 :items="organizationalObjectives" />
                <DropDownList label="Impact Weight"
                              v-model="impactWeight"
                              :help="impactWeightHelpText"
                              :items="impactWeightOptions"
                              :inputClasses="'input-width-lg'" />
                <CheckBoxList v-if="availablePreRequisites.length > 0"
                              v-model="preRequisites"
                              :items="availablePreRequisites"
                              label="Prerequisite Steps"
                              help="The steps that must be completed prior to this step."
                              vertical />
            </ContentStack>

            <ContentStack title="Completion Options" description="Set options to control how this step can be recorded, tracked, or completed.">
                <div class="form-group">
                    <InlineCheckBox v-model="allowMultiple"
                                    label="Allow Multiple"
                                    help="Determines if a person can complete a step more than once."
                                    class="mb-3" />
                    <InlineCheckBox v-model="hasEndDate"
                                    label="Spans Time"
                                    help="Determines if the step occurs at a specific point or over a period of time."
                                    class="mb-3" />
                    <InlineCheckBox v-model="isDateRequired"
                                    label="Is Date Required"
                                    help="Determines if the date for the step is required."
                                    class="mb-3" />
                </div>
            </ContentStack>

            <ContentStack title="Call To Action Path" description="Configure these settings to guide individuals on how to complete this step. Helpful when designing and building your website or mobile app.">
                <div class="form-group">
                    <TextBox v-model="callToActionLabel"
                             label="Call To Action Label"
                             help="The text shown on the action button (e.g., “Join Now” or “Start Step”). Keep it short, clear, and action-oriented to encourage engagement." />
                    <TextBox v-model="callToActionLink"
                             label="Call To Action Link"
                             help="The URL where the individual takes the next step. This can point to a form, page, or resource—wherever the action happens." />
                    <TextBox v-model="callToActionDescription"
                             label="Call To Action Description"
                             help="A brief message explaining what the action is and why it matters. Helps individuals understand the purpose and importance of the next step." />
                </div>
            </ContentStack>
        </ContentSection>

        <ContentSection v-if="hasAttributes" title="Step Type Attributes" icon="ti ti-binary-tree-2">
            <ContentStack title="Step Type Attributes"
                          description="Set the values for the Step Type Attributes configured from the Step Program level.">
                <AttributeValuesContainer v-model="attributeValues" :attributes="attributes" isEditMode :numberOfColumns="3" />
            </ContentStack>
        </ContentSection>

        <ContentSection title="Step Attributes" icon="ti ti-database">
            <ContentStack>
                <Grid :definition="props.modelValue.bag?.stepTypeAttributesGridDefinition ?? undefined"
                      :data="attributesGridDataSource"
                      light
                      keyField="idKey"
                      itemTerm="Attribute"
                      liveUpdates
                      :onAddItem="onAddAttribute">

                    <ReorderColumn v-if="props.options?.isReOrderColumnVisible" @orderChanged="onOrderChanged" />

                    <TextColumn name="attributeName"
                                title="Name"
                                field="attributeName"
                                :filter="textValueFilter"
                                visiblePriority="xs" />

                    <TextColumn name="fieldType"
                                title="Field Type"
                                field="fieldType"
                                :filter="textValueFilter"
                                visiblePriority="lg" />

                    <BooleanColumn name="allowSearch"
                                   title="Allow Search"
                                   field="allowSearch"
                                   :filter="booleanValueFilter"
                                   visiblePriority="xs" />

                    <EditColumn :onClick="onEditAttribute" />
                    <DeleteColumn :onClick="onDeleteAttribute" />
                </Grid>
            </ContentStack>
            <Modal v-model="isAttributeModalOpen" title="Step Attributes">

                <RockForm v-model:submit="submitEditAttribute" @submit="onSaveAttribute">
                    <AttributeEditor v-model="stepAttribute" :reservedKeyNames="reservedKeyNames" />
                </RockForm>

                <template #customButtons>
                    <RockButton :btnSize="BtnSize.Default"
                                :btnType="BtnType.Primary"
                                @click="onStartSaveAttribute">Save</RockButton>
                </template>

            </Modal>
        </ContentSection>

        <ContentSection title="Workflows" icon="ti ti-route-alt-right">
            <ContentStack>
                <Grid :definition="props.modelValue.bag?.workflowTriggerGridDefinition ?? undefined"
                      :data="workflowTriggersGridDataSource"
                      light
                      keyField="idKey"
                      itemTerm="Workflow"
                      liveUpdates
                      :onAddItem="onAddWorkflow">
                    <TextColumn name="workflowType"
                                title="Workflow Type"
                                field="workflowType"
                                :filter="textValueFilter"
                                visiblePriority="xs" />
                    <TextColumn name="workflowTrigger"
                                title="Trigger"
                                field="workflowTrigger"
                                :filter="textValueFilter"
                                visiblePriority="lg" />
                    <EditColumn :onClick="onEditWorkflow" />
                    <DeleteColumn :onClick="onDeleteWorkflow" />
                </Grid>
            </ContentStack>
            <Modal v-model="isWorkflowModalOpen" title="Select Workflow">
                <RockForm v-model:submit="submitWorkflowTrigger" @submit="onSaveWorkflow">
                    <fieldset>
                        <div class="row">
                            <div class="col-md-6">
                                <DropDownList v-model="triggerType"
                                              :items="triggerTypes"
                                              label="Launch Workflow When"
                                              rules="required" />
                            </div>
                            <div class="col-md-6">
                                <WorkflowTypePicker v-model="stepWorkflowTrigger.workflowType"
                                                    label="Workflow Type"
                                                    rules="required" />
                            </div>
                        </div>
                        <div class="row" v-if="showQualifiers">
                            <div class="col-md-6">
                                <DropDownList v-model="primaryQualifier" :items="stepStatuses" label="From" showBlankItem />
                                <DropDownList v-model="secondaryQualifier" :items="stepStatuses" label="To" showBlankItem />
                            </div>
                            <div class="col-md-6">
                            </div>
                        </div>
                    </fieldset>
                </RockForm>
                <template #customButtons>
                    <RockButton :btnSize="BtnSize.Default"
                                :btnType="BtnType.Primary"
                                @click="onStartSaveWorkflowTrigger">Save</RockButton>
                </template>
            </Modal>
        </ContentSection>

        <ContentSection title="Advanced Settings" icon="ti ti-adjustments-cog">
            <ContentStack>
                <div class="row">
                    <div class="col-md-2">
                        <DataViewPicker v-if="audienceDataView.value"
                                        v-model="audienceDataView"
                                        label="Audience Data View"
                                        help="A Data View that returns a list of people who are eligible to take this step." />
                        <DataViewPicker v-model="autoCompleteDataView"
                                        label="Auto-Complete Data View"
                                        help="A Data View that returns a list of people who should be regarded as having completed this step." />
                    </div>
                </div>
                <div class="row">
                    <div class="col-md-12">
                        <CodeEditor v-model="cardLavaTemplate"
                                    :editorHeight="200"
                                    mode="lava"
                                    theme="rock"
                                    label="Card Content Lava Template"
                                    help="The template to use when formatting the summary card for this step." />
                    </div>
                </div>
                <InlineCheckBox v-model="allowManualEditing"
                                label="Allow Manual Edit"
                                help="Can the step be manually added or edited?" />
            </ContentStack>
        </ContentSection>
    </ContentSectionContainer>
</template>
<script setup lang="ts">
    import { PropType, ref, watch, computed, reactive } from "vue";
    import AttributeValuesContainer from "@Obsidian/Controls/attributeValuesContainer.obs";
    import CheckBox from "@Obsidian/Controls/checkBox.obs";
    import InlineCheckBox from "@Obsidian/Controls/inlineCheckBox.obs";
    import TextBox from "@Obsidian/Controls/textBox.obs";
    import IconPicker from "@Obsidian/Controls/iconPicker.obs";
    import ColorPicker from "@Obsidian/Controls/colorPicker.obs";
    import CheckBoxList from "@Obsidian/Controls/checkBoxList.obs";
    import CodeEditor from "@Obsidian/Controls/codeEditor.obs";
    import DataViewPicker from "@Obsidian/Controls/dataViewPicker.obs";
    import Modal from "@Obsidian/Controls/modal.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import RadioButtonList from "@Obsidian/Controls/radioButtonList.obs";
    import WorkflowTypePicker from "@Obsidian/Controls/workflowTypePicker.obs";
    import ContentSectionContainer from "@Obsidian/Controls/contentSectionContainer.obs";
    import ContentSection from "@Obsidian/Controls/contentSection.obs";
    import ContentStack from "@Obsidian/Controls/contentStack.obs";
    import Grid, { BooleanColumn, EditColumn, TextColumn, textValueFilter, booleanValueFilter, DeleteColumn, ReorderColumn } from "@Obsidian/Controls/grid";
    import { setPropertiesBoxValue, watchPropertyChanges } from "@Obsidian/Utility/block";
    import { propertyRef, updateRefValue } from "@Obsidian/Utility/component";
    import { StepTypeBag } from "@Obsidian/ViewModels/Blocks/Engagement/StepTypeDetail/stepTypeBag";
    import { StepTypeDetailOptionsBag } from "@Obsidian/ViewModels/Blocks/Engagement/StepTypeDetail/stepTypeDetailOptionsBag";
    import { PublicEditableAttributeBag } from "@Obsidian/ViewModels/Utility/publicEditableAttributeBag";
    import AttributeEditor from "@Obsidian/Controls/attributeEditor.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import RockForm from "@Obsidian/Controls/rockForm.obs";
    import { BtnType } from "@Obsidian/Enums/Controls/btnType";
    import { BtnSize } from "@Obsidian/Enums/Controls/btnSize";
    import { StepAttributeBag } from "@Obsidian/ViewModels/Blocks/Engagement/StepTypeDetail/stepAttributeBag";
    import { StepTypeWorkflowTriggerBag } from "@Obsidian/ViewModels/Blocks/Engagement/StepTypeDetail/stepTypeWorkflowTriggerBag";
    import { GridDataBag } from "@Obsidian/ViewModels/Core/Grid/gridDataBag";
    import { FieldType } from "@Obsidian/SystemGuids/fieldType";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { emptyGuid, newGuid } from "@Obsidian/Utility/guid";
    import { enumToListItemBag } from "@Obsidian/Utility/enumUtils";
    import { EngagementType, EngagementTypeDescription } from "@Obsidian/Enums/Engagement/engagementType";
    import { ValidPropertiesBox } from "@Obsidian/ViewModels/Utility/validPropertiesBox";
    import { useInvokeBlockAction } from "@Obsidian/Utility/block";
    const props = defineProps({
        modelValue: {
            type: Object as PropType<ValidPropertiesBox<StepTypeBag>>,
            required: true
        },
        options: {
            type: Object as PropType<StepTypeDetailOptionsBag>,
            required: true
        }
    });
    const emit = defineEmits<{
        (e: "update:modelValue", value: ValidPropertiesBox<StepTypeBag>): void,
        (e: "propertyChanged", value: string): void
    }>();

    // #region Values

    const attributes = ref(props.modelValue.bag?.attributes ?? {});
    const attributeValues = ref(props.modelValue.bag?.attributeValues ?? {});
    const description = propertyRef(props.modelValue.bag?.description ?? "", "Description");
    const isActive = propertyRef(props.modelValue.bag?.isActive ?? false, "IsActive");
    const name = propertyRef(props.modelValue.bag?.name ?? "", "Name");
    const iconCssClass = propertyRef(props.modelValue.bag?.iconCssClass ?? "", "IconCssClass");
    const engagementType = propertyRef(props.modelValue.bag?.engagementType?.toString() ?? EngagementType.None.toString(), "EngagementType");
    const organizationalObjectiveValue = propertyRef(props.modelValue.bag?.organizationalObjectiveValue?.value?.toString() ?? emptyGuid, "OrganizationalObjectiveValueId");
    const impactWeight = propertyRef(props.modelValue.bag?.impactWeight?.toString() ?? "", "ImpactWeight");
    const callToActionLabel = propertyRef(props.modelValue.bag?.callToActionLabel ?? "", "CallToActionLabel");
    const callToActionLink = propertyRef(props.modelValue.bag?.callToActionLink ?? "", "CallToActionLink");
    const callToActionDescription = propertyRef(props.modelValue.bag?.callToActionDescription ?? "", "CallToActionDescription");
    const highlightColor = propertyRef(props.modelValue.bag?.highlightColor ?? "", "HighlightColor");
    const allowMultiple = propertyRef(props.modelValue.bag?.allowMultiple ?? false, "AllowMultiple");
    const hasEndDate = propertyRef(props.modelValue.bag?.hasEndDate ?? false, "HasEndDate");
    const showCountOnBadge = propertyRef(props.modelValue.bag?.showCountOnBadge ?? false, "ShowCountOnBadge");
    const isDateRequired = propertyRef(props.modelValue.bag?.isDateRequired ?? false, "IsDateRequired");
    const autoCompleteDataView = propertyRef(props.modelValue.bag?.autoCompleteDataView ?? {}, "AutoCompleteDataViewId");
    const audienceDataView = propertyRef(props.modelValue.bag?.audienceDataView ?? {}, "AudienceDataViewId");
    const allowManualEditing = propertyRef(props.modelValue.bag?.allowManualEditing ?? false, "AllowManualEditing");
    const preRequisites = ref(props.modelValue.bag?.preRequisites ?? []);
    const availablePreRequisites = ref(props.modelValue.bag?.availablePreRequisites ?? []);
    const cardLavaTemplate = propertyRef(props.modelValue.bag?.cardLavaTemplate ?? "", "CardLavaTemplate");
    const isWorkflowModalOpen = ref(false);
    const triggerType = ref("");
    const triggerTypes = ref(props.options.triggerTypes ?? []);
    const organizationalObjectives = (props.options.organizationalObjectives ?? []);
    const stepStatuses = ref<ListItemBag[]>(
        (props.options.stepStatuses?.map(s => s.stepStatus).filter((s): s is ListItemBag => !!s)) ?? []
    );
    const primaryQualifier = ref("");
    const secondaryQualifier = ref("");
    const stepWorkflowTrigger = ref<StepTypeWorkflowTriggerBag>({});
    const stepWorkflowTriggers = ref(props.modelValue.bag?.workflows ?? []);
    const submitWorkflowTrigger = ref(false);
    const workflowTriggersGridData = reactive(props.modelValue.bag?.workflowTriggerGridData ?? {});
    const workflowTriggersGridDataSource = ref<GridDataBag>(workflowTriggersGridData);
    const stepAttributes = ref(props.modelValue.bag?.stepAttributes ?? []);
    const isAttributeModalOpen = ref(false);
    const submitEditAttribute = ref(false);
    const stepAttribute = ref<PublicEditableAttributeBag | null>(null);
    const reservedKeyNames = ref<string[]>([]);
    const attributesGridData = reactive(props.modelValue.bag?.stepTypeAttributesGridData ?? {});
    const attributesGridDataSource = ref<GridDataBag>(attributesGridData);

    const engagementTypes = enumToListItemBag(EngagementTypeDescription);
    const engagementTypeHelpText = `Defines how individuals interact with this step over time.<br/><br/>
            Choose <strong>Milestone</strong> for one-time accomplishments or <strong>Rhythm</strong> for ongoing patterns of involvement.
            This helps clarify reporting and individual progress.`;

    const impactWeightHelpText = `Represents the level of effort or friction an individual must invest to complete a step.<br/><br/>
            Not all steps carry the same weight—some require more time and/or commitment. This value helps measure the overall impact of a program beyond just step count, giving insight into the depth of engagement.`;
    const impactWeightOptions: ListItemBag[] = [
        { text: "1 - Low Impact", value: "1" },
        { text: "2 - Low-Medium Impact", value: "2" },
        { text: "3 - Medium Impact", value: "3" },
        { text: "4 - Medium-High Impact", value: "4" },
        { text: "5 - High Impact", value: "5" }
    ];
    const invokeBlockAction = useInvokeBlockAction();

    // The properties that are being edited. This should only contain
    // objects returned by propertyRef().
    const propRefs = [description, isActive, name, iconCssClass, highlightColor, engagementType, organizationalObjectiveValue, impactWeight, callToActionLabel, callToActionLink, callToActionDescription, allowMultiple, hasEndDate, showCountOnBadge, isDateRequired,
        autoCompleteDataView, audienceDataView, allowManualEditing, cardLavaTemplate];

    // #endregion

    // #region Computed Values
    const showQualifiers = computed(() => {
        return triggerType.value === "StatusChanged";
    });

    const hasAttributes = computed(() => {
        return Object.keys(attributes.value).length > 0;
    });
    // #endregion

    // #region Functions
    function getTriggerDescription(triggerType: string, primaryQualifier: string | null | undefined, secondaryQualifier: string | null | undefined): string {
        if (triggerType == "StatusChanged") {

            let status = stepStatuses.value.find(x => x.value == primaryQualifier);
            const fromStatus = !status?.text ? "[Any]" : status.text;

            status = stepStatuses.value.find(x => x.value == secondaryQualifier);

            const toStatus = !status?.text ? "[Any]" : status.text;

            const description = `Status Change: ${fromStatus} to ${toStatus}`;

            return description;
        }
        else if (triggerType == "IsComplete") {
            return "Step Completed";
        }
        else {
            return triggerType;
        }
    }
    // #endregion

    // #region Event Handlers

    const onAddWorkflow = (): void => {
        // Reset statuses and show modal.
        stepWorkflowTrigger.value = {};
        triggerType.value = "";
        primaryQualifier.value = "";
        secondaryQualifier.value = "";
        isWorkflowModalOpen.value = true;
    };

    const onEditWorkflow = (key: string): void => {
        const workflow = stepWorkflowTriggers.value.find(x => x.idKey == key);
        if (workflow) {
            stepWorkflowTrigger.value = workflow;
            triggerType.value = workflow.workflowTrigger?.value ?? "";
            primaryQualifier.value = workflow.primaryQualifier ?? "";
            secondaryQualifier.value = workflow.secondaryQualifier ?? "";
        }
        isWorkflowModalOpen.value = true;
    };

    const onDeleteWorkflow = async (key: string): Promise<void> => {
        // Close modal and remove deleted trigger from the current collection  of triggers.
        isWorkflowModalOpen.value = false;
        stepWorkflowTriggers.value = stepWorkflowTriggers.value.filter(s => s.idKey !== key);

        // Update the grid.
        if (workflowTriggersGridData.rows) {
            const index = workflowTriggersGridData.rows.findIndex(r => r["idKey"] === key);

            if (index !== -1) {
                workflowTriggersGridData.rows?.splice(index, 1);
            }
        }
    };

    const onSaveWorkflow = (): void => {
        isWorkflowModalOpen.value = false;
        const selectedTriggerType = triggerTypes.value.find(t => t.value == triggerType.value);

        if (triggerType.value && stepWorkflowTrigger.value.workflowType?.value && workflowTriggersGridData.rows && selectedTriggerType?.value) {
            const index = stepWorkflowTriggers.value.findIndex(a => (a.idKey === stepWorkflowTrigger.value.idKey));
            const workflowTrigger: ListItemBag = {
                text: getTriggerDescription(triggerType.value, primaryQualifier.value, secondaryQualifier.value),
                value: selectedTriggerType.value
            };

            if (index !== -1) {
                // Get the updated WorkflowTrigger and RowItem.
                let editedWorkflowTrigger = stepWorkflowTriggers.value.find(a => a.idKey == stepWorkflowTrigger.value.idKey);
                let rowItem = workflowTriggersGridData.rows.find(x => x["idKey"] == stepWorkflowTrigger.value.idKey);

                if (editedWorkflowTrigger && rowItem) {
                    // Replace old WorkflowTrigger with updated WorkflowTrigger.
                    editedWorkflowTrigger.workflowTrigger = workflowTrigger;
                    editedWorkflowTrigger.primaryQualifier = primaryQualifier.value;
                    editedWorkflowTrigger.secondaryQualifier = secondaryQualifier.value;
                    stepWorkflowTriggers.value.splice(index, 1, editedWorkflowTrigger);

                    // Update the GridRowItem with changes
                    const rowIndex = workflowTriggersGridData.rows.findIndex(r => r["idKey"] === stepWorkflowTrigger.value.idKey);
                    rowItem = getWorkflowTriggerGridRowItem(editedWorkflowTrigger);
                    workflowTriggersGridData.rows?.splice(rowIndex, 1, rowItem);
                }
            }
            else {
                // Create new entry and set the size of the current triggers as a pseudo id so
                // it can be tracked for frontend edits and deletes
                const currentLength = stepWorkflowTriggers.value.length + 1;
                const newWorkflowTrigger: StepTypeWorkflowTriggerBag = {
                    workflowTrigger: workflowTrigger,
                    workflowType: stepWorkflowTrigger.value.workflowType,
                    primaryQualifier: primaryQualifier.value,
                    secondaryQualifier: secondaryQualifier.value,
                    idKey: currentLength.toString()
                };
                stepWorkflowTriggers.value.push(newWorkflowTrigger);

                // Add new RowItem to the grid to represent the newly added trigger.
                const newRowItem = getWorkflowTriggerGridRowItem(newWorkflowTrigger);
                workflowTriggersGridData.rows.push(newRowItem);
            }
        }

        stepWorkflowTrigger.value = {};
        triggerType.value = "";
        primaryQualifier.value = "";
        secondaryQualifier.value = "";
    };

    const getWorkflowTriggerGridRowItem = (workflowTrigger: StepTypeWorkflowTriggerBag): Record<string, unknown> => {
        const rowItem: Record<string, unknown> = {};

        rowItem["idKey"] = workflowTrigger?.idKey;
        rowItem["workflowType"] = workflowTrigger.workflowType?.text;
        rowItem["workflowTrigger"] = workflowTrigger.workflowTrigger?.text;

        return rowItem;
    };

    const onStartSaveWorkflowTrigger = (): void => {
        submitWorkflowTrigger.value = true;
    };

    const onAddAttribute = async (): Promise<void> => {
        stepAttribute.value = {
            fieldTypeGuid: FieldType.Text,
        } as PublicEditableAttributeBag;
        isAttributeModalOpen.value = true;
    };

    const onEditAttribute = async (key: string): Promise<void> => {

        const selectedStepAttribute = stepAttributes.value.find(x => x.attribute?.guid === key);
        // If attribute exists set it as current attribute for editing.
        if (selectedStepAttribute?.attribute) {
            stepAttribute.value = selectedStepAttribute.attribute;
            isAttributeModalOpen.value = true;
        }
        else {
            onAddAttribute();
        }
    };

    const onDeleteAttribute = async (key: string): Promise<void> => {
        // Close modal and remove deleted attribute from the current collection of attributes.
        isAttributeModalOpen.value = false;
        const deletedAttribute = stepAttributes.value.find(a => a.attribute?.guid == key);
        stepAttributes.value = stepAttributes.value.filter(s => s.attribute?.guid !== key);
        reservedKeyNames.value = reservedKeyNames.value.filter(r => r !== deletedAttribute?.attribute?.key);

        // Update the grid.
        if (attributesGridData.rows) {
            const index = attributesGridData.rows.findIndex(r => r["idKey"] === key);

            if (index !== -1) {
                attributesGridData.rows?.splice(index, 1);
            }
        }
    };

    const onSaveAttribute = (): void => {

        if (stepAttribute.value && stepAttributes.value && attributesGridData.rows) {
            const index = stepAttributes.value.findIndex(a => a.attribute?.guid === stepAttribute.value?.guid);

            if (index !== -1) {
                // Get the updated attribute and rowItem.
                let editedAttribute = stepAttributes.value.find(a => a.attribute?.guid == stepAttribute.value?.guid);
                let rowItem = attributesGridData.rows.find(x => x["idKey"] == stepAttribute.value?.guid);

                if (editedAttribute && rowItem) {
                    // Replace old attribute with updated attribute.
                    editedAttribute.attribute = stepAttribute.value;
                    stepAttributes.value.splice(index, 1, editedAttribute);

                    // Update GridRowItem so changes are reflected in the UI.
                    const rowIndex = attributesGridData.rows.findIndex(r => r["idKey"] === stepAttribute.value?.guid);
                    rowItem = getAttributeGridRowItem(editedAttribute);
                    attributesGridData.rows?.splice(rowIndex, 1, rowItem);
                }
            }
            else {
                // Create new attribute if existing attribute with same key was not found.
                stepAttribute.value.guid = newGuid();
                const newStepAttribute: StepAttributeBag = {
                    attribute: stepAttribute.value,
                    fieldType: "",
                };
                stepAttributes.value.push(newStepAttribute);

                // Add new RowItem to the grid to represent the newly added attribute.
                const newRowItem = getAttributeGridRowItem(newStepAttribute);
                attributesGridData.rows.push(newRowItem);
            }

            isAttributeModalOpen.value = false;
            stepAttribute.value = null;
        }
    };

    async function onOrderChanged(item: Record<string, unknown>, beforeItem: Record<string, unknown> | null): Promise<boolean> {
        try {
            const result = await invokeBlockAction<string>("ReorderItem", {
                key: item["idKey"],
                beforeKey: beforeItem?.["idKey"] ?? null
            });
            return result.isSuccess;
        }
        catch (error) {
            console.error("Error reordering step attributes:", error);
            return false;
        }
    }

    const getAttributeGridRowItem = (stepAttribute: StepAttributeBag): Record<string, unknown> => {
        const rowItem: Record<string, unknown> = {};

        rowItem["idKey"] = stepAttribute.attribute?.guid;
        rowItem["attributeName"] = stepAttribute.attribute?.name;
        rowItem["fieldType"] = stepAttribute.fieldType;
        rowItem["allowSearch"] = stepAttribute.attribute?.isAllowSearch;

        if (stepAttribute.attribute?.key && !reservedKeyNames.value.includes(stepAttribute.attribute?.key)) {
            reservedKeyNames.value.push(stepAttribute.attribute.key);
        }

        return rowItem;
    };

    const onStartSaveAttribute = (): void => {
        submitEditAttribute.value = true;
    };

    watch(isAttributeModalOpen, () => {
        if (isAttributeModalOpen.value) {
            reservedKeyNames.value = reservedKeyNames.value.filter(k => k !== stepAttribute.value?.key);
        }
        else {
            if (stepAttribute.value?.key && !reservedKeyNames.value.some(k => k === stepAttribute.value?.key)) {
                reservedKeyNames.value.push(stepAttribute.value.key);
            }
        }
    });

    // #endregion

    // Watch for parental changes in our model value and update all our values.
    watch(() => props.modelValue.bag, () => {
        updateRefValue(attributes, props.modelValue.bag?.attributes ?? {});
        updateRefValue(attributeValues, props.modelValue.bag?.attributeValues ?? {});
        updateRefValue(description, props.modelValue.bag?.description ?? "");
        updateRefValue(isActive, props.modelValue.bag?.isActive ?? false);
        updateRefValue(name, props.modelValue.bag?.name ?? "");
        updateRefValue(iconCssClass, props.modelValue.bag?.iconCssClass ?? "");
        updateRefValue(highlightColor, props.modelValue.bag?.highlightColor ?? "");
        updateRefValue(allowMultiple, props.modelValue.bag?.allowMultiple ?? false);
        updateRefValue(hasEndDate, props.modelValue.bag?.hasEndDate ?? false);
        updateRefValue(showCountOnBadge, props.modelValue.bag?.showCountOnBadge ?? false);
        updateRefValue(isDateRequired, props.modelValue.bag?.isDateRequired ?? false);
        updateRefValue(autoCompleteDataView, props.modelValue.bag?.autoCompleteDataView ?? {});
        updateRefValue(audienceDataView, props.modelValue.bag?.audienceDataView ?? {});
        updateRefValue(allowManualEditing, props.modelValue.bag?.allowManualEditing ?? false);
        updateRefValue(engagementType, props.modelValue.bag?.engagementType?.toString() ?? EngagementType.None.toString());
        updateRefValue(organizationalObjectiveValue, props.modelValue.bag?.organizationalObjectiveValue?.value?.toString() ?? emptyGuid);
        updateRefValue(impactWeight, props.modelValue.bag?.impactWeight?.toString() ?? "");
        updateRefValue(callToActionLabel, props.modelValue.bag?.callToActionLabel ?? "");
        updateRefValue(callToActionLink, props.modelValue.bag?.callToActionLink ?? "");
        updateRefValue(callToActionDescription, props.modelValue.bag?.callToActionDescription ?? "");
        updateRefValue(preRequisites, props.modelValue.bag?.preRequisites ?? []);
        updateRefValue(availablePreRequisites, props.modelValue.bag?.availablePreRequisites ?? []);
        updateRefValue(cardLavaTemplate, props.modelValue.bag?.cardLavaTemplate ?? "");
    });

    // Determines which values we want to track changes on (defined in the
    // array) and then emit a new object defined as newValue.
    watch([attributeValues, stepAttributes, stepWorkflowTriggers, preRequisites, ...propRefs], () => {
        const newValue: ValidPropertiesBox<StepTypeBag> = {
            bag: { ...props.modelValue.bag } as StepTypeBag,
            validProperties: props.modelValue.validProperties
        };

        setPropertiesBoxValue(newValue, "attributeValues", attributeValues.value);
        setPropertiesBoxValue(newValue, "description", description.value);
        setPropertiesBoxValue(newValue, "isActive", isActive.value);
        setPropertiesBoxValue(newValue, "name", name.value);
        setPropertiesBoxValue(newValue, "iconCssClass", iconCssClass.value);
        setPropertiesBoxValue(newValue, "highlightColor", highlightColor.value);
        setPropertiesBoxValue(newValue, "allowMultiple", allowMultiple.value);
        setPropertiesBoxValue(newValue, "hasEndDate", hasEndDate.value);
        setPropertiesBoxValue(newValue, "showCountOnBadge", showCountOnBadge.value);
        setPropertiesBoxValue(newValue, "isDateRequired", isDateRequired.value);
        setPropertiesBoxValue(newValue, "autoCompleteDataView", autoCompleteDataView.value);
        setPropertiesBoxValue(newValue, "allowManualEditing", allowManualEditing.value);
        setPropertiesBoxValue(newValue, "engagementType", parseInt(engagementType.value) as EngagementType);
        setPropertiesBoxValue(newValue, "organizationalObjectiveValue", organizationalObjectiveValue.value ? { value: organizationalObjectiveValue.value } as ListItemBag : null);
        setPropertiesBoxValue(newValue, "impactWeight", parseInt(impactWeight.value));
        setPropertiesBoxValue(newValue, "callToActionLabel", callToActionLabel.value);
        setPropertiesBoxValue(newValue, "callToActionLink", callToActionLink.value);
        setPropertiesBoxValue(newValue, "callToActionDescription", callToActionDescription.value);
        setPropertiesBoxValue(newValue, "preRequisites", preRequisites.value);
        setPropertiesBoxValue(newValue, "cardLavaTemplate", cardLavaTemplate.value);
        setPropertiesBoxValue(newValue, "stepAttributes", stepAttributes.value);
        setPropertiesBoxValue(newValue, "workflows", stepWorkflowTriggers.value);
        setPropertiesBoxValue(newValue, "audienceDataView", audienceDataView.value);

        emit("update:modelValue", newValue);
    });

    // Watch for any changes to props that represent properties and then
    // automatically emit which property changed.
    watchPropertyChanges(propRefs, emit);
</script>
