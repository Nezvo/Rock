<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <fieldset>
        <div id="pnlViewDetails" runat="server">
            <h3 class="mt-1">
                {{ name }} Step Type
            </h3>
            <div class="row">
                <div class="col-md-6">
                    <div class="description">{{ description }}</div>
                </div>
                <div class="col-xs-12 col-sm-6 d-flex align-items-start justify-content-end">
                    <SlidingDateRangePicker v-model="filterDate"
                                            :enabledSlidingDateRangeUnits="[RangeType.Previous, RangeType.Last, RangeType.Current, RangeType.DateRange]"
                                            :enabledTimeUnits="[TimeUnit.Week, TimeUnit.Month, TimeUnit.Year]"
                                            :isRangeClearable="false"
                                            class="pull-right"
                                            previewLocation="None" />
                </div>
            </div>
            <div v-html="kpi"></div>
            <div>
                <div v-if="isLoading">
                    <Loading :isLoading="isLoading" />
                </div>
                <NotificationBox v-else-if="notificationMessage" alertType="info">{{ notificationMessage }}</NotificationBox>
                <div v-else style="height: 300px">
                    <LineChart :series="chartSeries"
                               :labels="chartLabels"
                               :labelDateFormat="dateUnit"
                               :valueSuggestedMin="0" />
                </div>
            </div>
        </div>

    </fieldset>
</template>

<style scoped>
.margin-y-xsmall {
    margin: var(--spacing-xsmall) 0;
}
</style>

<script setup lang="ts">
    import { PropType, ref, watch, onMounted } from "vue";
    import { useInvokeBlockAction, useBlockBrowserBus } from "@Obsidian/Utility/block";
    import SlidingDateRangePicker from "@Obsidian/Controls/slidingDateRangePicker.obs";
    import { RangeType, SlidingDateRange, TimeUnit, calculateSlidingDateRange } from "@Obsidian/Utility/slidingDateRange";
    import NotificationBox from "@Obsidian/Controls/notificationBox.obs";
    import LineChart from "@Obsidian/Controls/lineChart.obs";
    import Loading from "@Obsidian/Controls/loading.obs";
    import { StepTypeBag } from "@Obsidian/ViewModels/Blocks/Engagement/StepTypeDetail/stepTypeBag";
    import { StepTypeDetailOptionsBag } from "@Obsidian/ViewModels/Blocks/Engagement/StepTypeDetail/stepTypeDetailOptionsBag";
    import { ChartDataBag } from "@Obsidian/ViewModels/Blocks/Engagement/StepProgramDetail/chartDataBag";
    import { LineSeries } from "@Obsidian/Core/Controls/chart";
    import { isNullOrWhiteSpace } from "@Obsidian/Utility/stringUtils";
    import { getCssVariableValue } from "@Obsidian/Utility/cssUtils";
    import { PageMessages } from "@Obsidian/Utility/browserBus";
    import { ContextEntityChangedData, Message } from "@Obsidian/Types/Utility/browserBus";
    import { areEqual } from "@Obsidian/Utility/guid";
    import { EntityType } from "@Obsidian/SystemGuids/entityType";

    const props = defineProps({
        modelValue: {
            type: Object as PropType<StepTypeBag | null>,
            required: false
        },

        options: {
            type: Object as PropType<StepTypeDetailOptionsBag>,
            required: true
        }
    });

    // #region Values
    const name = ref(props.modelValue?.name ?? "");
    const description = ref(props.modelValue?.description ?? "");
    const kpi = ref(props.modelValue?.kpi ?? "");
    const notificationMessage = ref();
    const filterDate = ref(props.modelValue?.defaultDateRange as SlidingDateRange);
    const isLoading = ref(false);
    const chartLabels = ref<string[]>([]);
    const chartSeries = ref<LineSeries[]>([]);
    const dateUnit = ref<"day" | "month" | "year" | undefined>();

    const customColors = [getCssVariableValue("--color-categorical-1"), getCssVariableValue("--color-categorical-3")];

    const invokeBlockAction = useInvokeBlockAction();
    const browserBus = useBlockBrowserBus();

    browserBus.subscribe(PageMessages.ContextEntityChanged, async (message: Message<ContextEntityChangedData>) => {
        if (areEqual(message.data.entityTypeGuid, EntityType.Campus)) {
            fetchChartData();
        }
    });

    // #endregion

    // #region Event Handlers

    async function fetchChartData(): Promise<void> {
        if (isLoading.value) {
            // Still Loading Previous Request. Don't want to start another one.
            return;
        }

        isLoading.value = true;
        chartLabels.value = [];
        chartSeries.value = [];
        notificationMessage.value = "";

        const dates = calculateSlidingDateRange(filterDate.value);

        if (!dates.start || !dates.end) {
            notificationMessage.value = "Please select a valid date range to display chart data.";
            isLoading.value = false;
            return;
        }

        const result = await invokeBlockAction<ChartDataBag>("GetChartData", {
            startDateTime: dates.start.toISOString(),
            endDateTime: dates.end.toISOString(),
        });

        isLoading.value = false;

        if (result.isSuccess && result.data) {
            chartLabels.value = result.data.dateLabels ?? [];

            const lineSeries = (result.data.series ?? []).map((s, index) => ({
                ...s,
                color: customColors[index]
            }));

            chartSeries.value = lineSeries as LineSeries[];

            if (!isNullOrWhiteSpace(result.data.timeUnit)) {
                const unit = result.data.timeUnit;
                if (unit === "day" || unit === "month" || unit === "year") {
                    dateUnit.value = unit;
                }
            }
        }
        else {
            notificationMessage.value = result.errorMessage ?? "Unknown error while trying to refresh chart.";
        }
    }

    // #endregion

    watch(filterDate, () => {
        fetchChartData();
    });

    onMounted(() => {
        fetchChartData();
    });
</script>
