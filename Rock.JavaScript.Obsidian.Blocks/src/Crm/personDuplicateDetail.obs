<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Grid :definition="config.gridDefinition ?? undefined"
          title="Person Duplicates"
          :data="gridDataSource"
          keyField="idKey"
          personKeyField="personIdKey"
          itemTerm="Person Duplicate"
          :entityTypeGuid="EntityType.PersonDuplicate"
          stickyHeader
          liveUpdates
          @selectItem="onSelectItem"
          :isCountMessageVisible="false"
          :selectedKeysOverride="selectedKeysOverride">

        <SelectColumn :enableRowExclusions="true"
                      :excludeRow="excludeRow"
                      :forceAllowSelectAll="true" />
        <HtmlColumn name="confidenceScore"
                    title="Confidence"
                    field="confidenceScore" />
        <Column v-if="config.options?.hasMultipleCampuses"
                name="campus"
                title="Campus"
                field="campus" />
        <HtmlColumn name="accountProtectionProfile"
                    title="Account Protection Profile"
                    field="accountProtectionProfile" />
        <Column name="firstName"
                title="First Name"
                field="firstName" />
        <Column name="lastName"
                title="Last Name"
                field="lastName" />
        <Column name="email"
                title="Email"
                field="email" />
        <Column name="gender"
                title="Gender"
                field="gender" />
        <Column name="age"
                title="Age"
                field="age" />
        <HtmlColumn name="addresses"
                    title="Addresses"
                    field="addresses" />
        <HtmlColumn name="phoneNumbers"
                    title="Phone Numbers"
                    field="phoneNumbers" />

        <AttributeColumns :attributes="config.gridDefinition?.attributeFields ?? []" />
    </Grid>
</template>

<script setup lang="ts">
    import { onConfigurationValuesChanged, useConfigurationValues, useInvokeBlockAction, useReloadBlock } from "@Obsidian/Utility/block";
    import { EntityType } from "@Obsidian/SystemGuids/entityType";
    import Grid, { Column, HtmlColumn, AttributeColumns, SelectColumn } from "@Obsidian/Controls/grid";
    import { ListBlockBox } from "@Obsidian/ViewModels/Blocks/listBlockBox";
    import { PersonDuplicateDetailOptionsBag } from "@Obsidian/ViewModels/Blocks/Crm/PersonDuplicateDetail/personDuplicateDetailOptionsBag";
    import { GridDataBag } from "@Obsidian/ViewModels/Core/Grid/gridDataBag";
    import { NavigationUrlKey } from "./PersonDuplicateDetail/types.partial";
    import { reactive, ref } from "vue";

    const config = useConfigurationValues<ListBlockBox<PersonDuplicateDetailOptionsBag>>();
    const invokeBlockAction = useInvokeBlockAction();

    // All blocks auto reload when changing block settings unless there is an
    // explicit reason not to (like using a custom reload function instead),
    // in which case you can remove this code.
    onConfigurationValuesChanged(useReloadBlock());

    // #region Values

    const gridDataSource = ref<Promise<GridDataBag>>();
    let combinedGridData: GridDataBag | undefined;

    // #endregion

    // #region Functions

    /**
     * Called when the grid is requesting the row data be loaded.
     */
    async function loadGridData(): Promise<GridDataBag> {
        const duplicates = await invokeBlockAction<GridDataBag>("GetGridData");

        if (duplicates.isSuccess && duplicates.data) {
            const person = await invokeBlockAction<GridDataBag>("GetPerson");
            if (person.isSuccess && person.data) {
                let personGridData = reactive(person.data) as GridDataBag;
                let duplicateGridData = reactive(duplicates.data) as GridDataBag;

                combinedGridData = {
                    ...personGridData,
                    rows: [
                        ...(personGridData.rows ?? []),
                        ...(duplicateGridData.rows ?? [])
                    ]
                } as GridDataBag;

                combinedGridData = formatConfidenceScores(combinedGridData);
                combinedGridData = formatAccountProtectionProfiles(combinedGridData);
                combinedGridData = formatAddresses(combinedGridData);
                combinedGridData = formatPhoneNumbers(combinedGridData);
                return combinedGridData;
            }
            else {
                throw new Error(duplicates.errorMessage ?? "Unknown error while trying to load person grid data.");
            }
        }
        else {
            throw new Error(duplicates.errorMessage ?? "Unknown error while trying to load duplicate grid data.");
        }
    }
    /**
     * Formats the confidence scores in the provided GridDataBag.
     * - Converts the confidence score to a percentage string with two decimal places.
     * - Applies a label class based on the score's value (success, warning, or default).
     *
     * @param {GridDataBag} data - The data object containing rows to format.
     * @returns {GridDataBag} The data object with formatted confidence scores.
     */

    function formatConfidenceScores(data: GridDataBag): GridDataBag {
        if (data?.rows) {
            data.rows.forEach(row => {
                const score = Number(row["confidenceScore"]);
                let formattedScore = "0.00%";

                if (!isNaN(score)) {
                    formattedScore = `${score.toFixed(2)}%`;
                }

                if (score >= Number(config.options?.confidenceScoreHigh)) {
                    formattedScore = `<span class='label label-success'>${formattedScore}</span>`;
                }
                else if (score >= Number(config.options?.confidenceScoreLow)) {
                    formattedScore = `<span class='label label-warning'>${formattedScore}</span>`;
                }
                else {
                    formattedScore = ``;
                }
                row["confidenceScore"] = formattedScore;
            });
        }

        return data;
    }

    /**
     * Formats the account protection profiles in the provided GridDataBag.
     * - Converts the profile value to a labeled HTML span with appropriate styling.
     * - Handles "low", "medium", "high", "extreme", and unknown values.
     *
     * @param {GridDataBag} data - The data object containing rows to format.
     * @returns {GridDataBag} The data object with formatted account protection profiles.
     */
    function formatAccountProtectionProfiles(data: GridDataBag): GridDataBag {
        if (data?.rows) {
            data.rows.forEach(row => {
                const profile = String(row["accountProtectionProfile"]) ?? "";
                let formattedProfile = profile;

                switch (profile.toLowerCase()) {
                    case "low":
                        formattedProfile = "<span class='label label-success'>Low</span>";
                        break;
                    case "medium":
                        formattedProfile = "<span class='label label-warning'>Medium</span>";
                        break;
                    case "high":
                        formattedProfile = "<span class='label label-primary'>High</span>";
                        break;
                    case "extreme":
                        formattedProfile = "<span class='label label-danger'>Extreme</span>";
                        break;
                    default:
                        formattedProfile = "<span class='label label-light'>Unknown</span>";
                        break;
                }

                row["accountProtectionProfile"] = formattedProfile;
            });
        }

        return data;
    }

    /**
     * Formats the addresses in the provided GridDataBag.
     * - Converts the addresses array into an HTML unordered list.
     * - Each address is displayed with its value, street, and city/state/postal information.
     * - If no addresses are present, displays a "None" label.
     *
     * @param {GridDataBag} data - The data object containing rows to format.
     * @returns {GridDataBag} The data object with formatted addresses.
     */
    function formatAddresses(data: GridDataBag): GridDataBag {
        if (data?.rows) {
            data.rows.forEach(row => {
                const addresses = Array.isArray(row["addresses"]) ? row["addresses"] : [];

                if (addresses.length > 0) {
                    const addressList = addresses.map((address) => {
                        let addressHtml = `<li class="address clearfix"><strong>${address["value"] || ""}</strong>`;
                        if (address["key"]["street1"]) {
                            addressHtml += `<p>${address["key"]["street1"]}`;
                        }
                        if (address["key"]["street2"]) {
                            addressHtml += `<br>${address["key"]["street2"]}`;
                        }
                        const cityStatePostal = [address["key"]["city"], address["key"]["state"], address["key"]["postalCode"]]
                            .filter(x => x)
                            .join(", ");
                        if (cityStatePostal) {
                            addressHtml += `<br>${cityStatePostal}</p>`;
                        }
                        addressHtml += `</li>`;
                        return addressHtml;
                    }).join("");
                    row["addresses"] = `<ul class="list-unstyled">${addressList}</ul>`;
                }
                else {
                    row["addresses"] = "<span class='label label-light'>None</span>";
                }
            });
        }

        return data;
    }

    /**
     * Formats the phone numbers in the provided GridDataBag.
     * - Converts the phoneNumbers array into an HTML unordered list.
     * - Each phone number is displayed with its value and formatted number.
     * - If no phone numbers are present, displays a "None" label.
     *
     * @param {GridDataBag} data - The data object containing rows to format.
     * @returns {GridDataBag} The data object with formatted phone numbers.
     */
    function formatPhoneNumbers(data: GridDataBag): GridDataBag {
        if (data?.rows) {
            data.rows.forEach(row => {
                const phoneNumbers = Array.isArray(row["phoneNumbers"]) ? row["phoneNumbers"] : [];

                if (phoneNumbers.length > 0) {
                    const phoneList = phoneNumbers.map((phone) => {
                        return `
                            <li class="phone clearfix">
                                <strong>${phone["value"] || ""}</strong>
                                <p>${phone["key"]["numberFormatted"] || ""}</p>
                            </li>
                        `;
                    }).join("");
                    row["phoneNumbers"] = `<ul class="list-unstyled">${phoneList}</ul>`;
                }
                else {
                    row["phoneNumbers"] = "<span class='label label-light'>None</span>";
                }
            });
        }

        return data;
    }

    /**
     * Determines if a given row should be excluded from selection.
     * A row is excluded if it has the property 'isDuplicateRow' set to true.
     *
     * @param {unknown} row - The row object to evaluate.
     * @returns {boolean} True if the row should be excluded, false otherwise.
     */
    function excludeRow(row: unknown): boolean {
        if (row && typeof row === "object" && "isDuplicateRow" in row) {
            return Boolean((row as Record<string, unknown>)["isDuplicateRow"]);
        }
        return false;
    }

    /**
     * Forces the person being viewed to always be selected in the grid and
     * for all actions, such as merge, communication, etcetera to include them.
     *
     * @param {string[]} selectedKeys
     * @returns {string[]} The modified list of selected keys including the person being viewed.
     */
    function selectedKeysOverride(selectedKeys: string[]): string[] {
        const urlParams = new URLSearchParams(window.location.search);
        const personId = urlParams.get("PersonId");
        if (personId && !selectedKeys.includes(personId)) {
            selectedKeys.unshift(personId);
        }
        return selectedKeys;
    }

    // #endregion

    // #region Event Handlers

    /**
     * Called when a row has been selected by the individual.
     *
     * @param key The key of the row that was selected.
     */
    function onSelectItem(key: string): void {
        if (config.navigationUrls?.[NavigationUrlKey.DetailPage]) {
            window.location.href = config.navigationUrls[NavigationUrlKey.DetailPage].replace("((Key))", key);
        }
    }

    // #endregion

    gridDataSource.value = loadGridData();
</script>
