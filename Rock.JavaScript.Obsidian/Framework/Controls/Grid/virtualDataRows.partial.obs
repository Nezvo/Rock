<template>
    <div class="grid-body" ref="element">
        <div :style="beforePadStyle" />
        <DataRow v-if="hasRows"
                 v-for="(row, index) of virtualItems"
                 :key="props.grid.getRowKey(row)"
                 :columns="props.columns"
                 :row="row"
                 :grid="props.grid"
                 :tooltipField="props.tooltipField"
                 :isSelectable="isSelectable"
                 :isEven="(range.startIndex + index + 1) % 2 === 0"
                 monitorHeight
                 :markInactiveRows="markInactiveRows"
                 :class="getRowClass(row)"
                 @resize="onRowResize"
                 @click="onRowClick" />

        <div class="grid-row" v-else-if="emptyDataText">
            <div class="grid-cell table-empty">
                {{ emptyDataText }}
            </div>
        </div>

        <div class="grid-row" v-else>
            <div class="grid-cell table-empty">
                No {{ pluralItemTerm }} Found
            </div>
        </div>
        <div :style="afterPadStyle" />
    </div>
</template>

<script setup lang="ts">
    import DataRow from "./dataRow.partial.obs";
    import { ColumnDefinition, IGridState } from "@Obsidian/Types/Controls/grid";
    import { PropType, computed, onBeforeUnmount, onMounted, ref, watch } from "vue";
    import { useVirtualScroller } from "@Obsidian/Core/Utilities/virtualScroll";
    import { pluralize } from "@Obsidian/Utility/stringUtils";

    const props = defineProps({
        /**
         * The array of columns that should be displayed in the data rows.
         * This may be different than the columns defined in the grid but
         * must be a subset of them.
         */
        columns: {
            type: Array as PropType<ReadonlyArray<ColumnDefinition>>,
            required: true
        },

        /** The rows that contain the data to be displayed. */
        rows: {
            type: Array as PropType<Record<string, unknown>[]>,
            required: true
        },

        /** The grid that contains all the state information. */
        grid: {
            type: Object as PropType<IGridState>,
            required: true
        },

        /** The field that will be used to display per-row tooltips. */
        tooltipField: {
            type: String as PropType<string>,
            required: false
        },

        /** True if any data row is selectable. */
        isSelectable: {
            type: Boolean as PropType<boolean>,
            default: false
        },

        /** The term that identifies individual rows in the grid. */
        itemTerm: {
            type: String as PropType<string>,
            default: "item"
        },

        /**
         * If set to true, each row with an `isActive` property set to false
         * will be visually distinct
         */
        markInactiveRows: {
            type: Boolean,
            default: false
        },

        /**
         * A CSS class that will be applied to each row. If you supply a string,
         * will apply that directly. You can also use a function that takes the
         * row object and returns a string, which allows you to apply different
         * classes to different rows depending on the row data.
         */
        rowClass: {
            type: [String, Function] as PropType<string | ((row: Record<string, unknown>) => string)>,
            default: undefined
        },

        keyField: {
            type: String as PropType<string>,
            required: true
        },

        /**
         * The text to display in the empty data row. The default is an empty string (""), which indicates that this property is not set.
         */
        emptyDataText: {
            type: String,
            default: "",
            required: false,
        }
    });

    const emit = defineEmits<{
        (e: "click", key: string): void,
        (e: "width", width: { offsetWidth: number, scrollWidth: number }): void
    }>();

    // #region Values

    const element = ref<HTMLElement>();
    const rows = ref(props.rows);
    let resizeObserver: ResizeObserver | undefined;

    // #endregion

    // #region Computed Values

    /**
     * Whether or not there are any rows given
     */
    const hasRows = computed(() => {
        return props.rows.length > 0;
    });

    /**
     * Plural form of the itemTerm prop.
     */
    const pluralItemTerm = computed(() => {
        return pluralize(props.itemTerm);
    });

    // #endregion

    // #region Functions

    /**
     * Determine the class to apply to each row
     */
    function getRowClass(row: Record<string, unknown>): string | undefined {
        if (typeof props.rowClass === "string") {
            return props.rowClass;
        }

        if (typeof props.rowClass === "function") {
            return props.rowClass(row);
        }

        return undefined;
    }

    // #endregion

    // #region Event Handlers

    /**
     * Called when a single row has been clicked.
     *
     * @param key The key of the row that was clicked.
     */
    function onRowClick(key: string): void {
        emit("click", key);
    }

    /**
     * Called when the height of an item/row has changed, for example by the
     * width being changed causing text to wrap.
     *
     * @param key The key of the item whose height changed.
     * @param height The new height of the item.
     */
    function onRowResize(key: string, height: number): void {
        updateItemHeight(key, height);
    }

    // #endregion

    const {
        virtualItems,
        beforePadStyle,
        afterPadStyle,
        range,
        updateItemHeight
    } = useVirtualScroller({
        items: rows,
        itemKey: props.keyField,
        container: element,
        estimatedItemHeight: 58,
    });

    watch(() => props.rows, () => {
        rows.value = props.rows;
    });

    onBeforeUnmount(() => {
        if (resizeObserver) {
            resizeObserver.disconnect();
            resizeObserver = undefined;
        }
    });

    onMounted(() => {
        if (typeof ResizeObserver !== "undefined" && element.value) {

            resizeObserver = new ResizeObserver(() => {
                const payload = { offsetWidth: element.value?.offsetWidth ?? 0, scrollWidth: element.value?.scrollWidth ?? 0 };
                emit("width", payload);
            });

            resizeObserver.observe(element.value);
        }
    });

</script>
