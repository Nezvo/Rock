<template>
    <Chart :data="chartData" :options="chartOptions" type="line" />
</template>

<script setup lang="ts">
    import { computed, PropType } from "vue";
    import Chart from "./chart.obs";
    import { ChartNumericDataPointBag } from "@Obsidian/ViewModels/Reporting/chartNumericDataPointBag";
    import { ChartData, ChartDataset, ChartOptions, Point } from "chart.js";
    import { Enumerable, GroupedEnumerable } from "@Obsidian/Utility/linq";
    import { isNullish } from "@Obsidian/Utility/util";

    type ChartStyles = {
        fontFamily: string;
        fontColor: string;
        fontSize: number;
        fontWeight: string;
        legendBoxSize: number;
        fallbackColor: string;
    };

    type LegendConfig = {
        hide?: boolean;
        position?: "top" | "bottom" | "left" | "right";
    };

    type LabelAxisConfig = {
        type?:
        | "string"
        | "date.day"
        | "date.week"
        | "date.month"
        | "date.year";
    };

    type ValueAxisConfig = {
        type?: "number" | "percent";
        maxDecimalPlaces?: number;
        limits?: {
            min?: number;
            max?: number;
        };
        ticks?: {
            coarse?: number;
            fine?: number;
        };
        tooltip?: (label: string, value: number, formattedValue: string) => string | null | undefined;
    };

    type AxesConfig = {
        label?: LabelAxisConfig;
        value?: ValueAxisConfig;
    };

    const props = defineProps({
        modelValue: {
            type: Array as PropType<ChartNumericDataPointBag[]>,
            required: true
        },

        axes: {
            type: Object as PropType<AxesConfig | null | undefined>,
            default: ({
                label: { type: "string" },
                value: { type: "number" }
            })
        },

        legend: {
            type: Object as PropType<LegendConfig | null | undefined>
        },

        seriesSort: {
            type: Object as PropType<((a: string, b: string) => number) | string[] | null | undefined>
        },

        title: {
            type: String as PropType<string | null | undefined>,
        }
    });

    // #region Computed Values

    const seriesSortFunction = computed<((a: string, b: string) => number) | undefined>(() => {
        const seriesSort = props.seriesSort;
        if (seriesSort) {
            if (Array.isArray(seriesSort)) {
                return (a, b) => {
                    return seriesSort.indexOf(a) - seriesSort.indexOf(b);
                };
            }
            else {
                return seriesSort;
            }
        }
    });

    const chartStyles = computed<ChartStyles>(() => {
        return {
            fontFamily: getCssVar("--font-family-sans-serif", '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"'),
            fontColor: getCssVar("--color-interface-stronger", "#0D1117"),
            fontSize: parseInt(getCssVar("--font-size-small", "14")),
            fontWeight: getCssVar("--font-weight-semibold", "600"),
            legendBoxSize: parseInt(getCssVar("--spacing-large", "24")),
            fallbackColor: "#8e8e93"
        };
    });

    const chartData = computed<ChartData<"line">>(() => {
        const dataPointsEnumerable = Enumerable.from(props.modelValue);

        const labels = dataPointsEnumerable
            .select(d => d.label)
            .ofType((d): d is string => !isNullish(d))
            .distinct()
            .toArray();

        let groupedBySeries = dataPointsEnumerable
            .groupBy(d => d.seriesName)
            .ofType((group): group is GroupedEnumerable<string, ChartNumericDataPointBag> => {
                return !isNullish(group.key);
            });

        if (seriesSortFunction.value) {
            groupedBySeries = groupedBySeries
                .orderBy(group => group.key, seriesSortFunction.value);
        }

        return {
            labels,
            datasets: groupedBySeries
                .select<ChartDataset<"line", (number | Point | null)[]>>(group => {
                    // Convert to an array once so the grouped enumerable isn't iterated multiple times.
                    const groupArray = group.toArray();
                    const seriesDataColors = Enumerable.from(groupArray).select(d => d.color ?? chartStyles.value.fallbackColor).toArray();
                    const dataDictionary = Enumerable.from(groupArray).toDictionary(d => d.label, d => d.value);

                    // Data points are ordered by the labels,
                    // and if a label is missing in the data,
                    // it will use the last value.
                    // This fills in the gaps to create a smooth line.
                    let lastValue = 0;
                    const data = Enumerable.from(labels)
                        .select(label => {
                            if (dataDictionary.has(label)) {
                                lastValue = dataDictionary.get(label)!;
                            }

                            return lastValue;
                        })
                        .toArray();

                    return {
                        label: group.key,
                        data,
                        backgroundColor: seriesDataColors,
                        borderColor: seriesDataColors
                    };
                })
                .toArray()
        };
    });

    const chartOptions = computed<ChartOptions<"line">>(() => {
        return {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: !!props.title,
                    text: props.title ?? undefined,
                    color: chartStyles.value.fontColor,
                    font: {
                        family: chartStyles.value.fontFamily,
                        size: chartStyles.value.fontSize,
                        weight: chartStyles.value.fontWeight
                    }
                },
                legend: {
                    position: props.legend?.position ?? "bottom",
                    labels: {
                        boxWidth: chartStyles.value.legendBoxSize,
                        boxHeight: chartStyles.value.legendBoxSize,
                        font: {
                            family: chartStyles.value.fontFamily,
                            size: chartStyles.value.fontSize,
                            weight: chartStyles.value.fontWeight
                        },
                        color: chartStyles.value.fontColor
                    }
                },
                tooltip: props.axes?.value?.tooltip
                    ? {
                        callbacks: {
                            label: context => {
                                const label = context.dataset.label ?? "";
                                const value = context.parsed.y;
                                //const formattedValue = context.formattedValue; // This is not formatted as a percent.
                                const formattedValue = props.axes?.value?.type === "percent"
                                    ? value.toLocaleString(undefined, { style: "percent", maximumFractionDigits: props.axes?.value?.maxDecimalPlaces })
                                    : value.toLocaleString(undefined, { maximumFractionDigits: props.axes?.value?.maxDecimalPlaces });
                                const tooltip = props.axes?.value?.tooltip?.(label, value, formattedValue);

                                if (tooltip) {
                                    return tooltip;
                                }
                            }
                        }
                    }
                    : {
                        callbacks: {
                            label: context => {
                                let label = context.dataset.label || "";

                                if (label) {
                                    label += ": ";
                                }

                                if (context.parsed.y !== null) {
                                    if (props.axes?.value?.type === "percent") {
                                        label += context.parsed.y.toLocaleString(undefined, { style: "percent", maximumFractionDigits: props.axes?.value?.maxDecimalPlaces });
                                    }
                                    else {
                                        label += context.parsed.y.toLocaleString(undefined, { maximumFractionDigits: props.axes?.value?.maxDecimalPlaces });
                                    }
                                }

                                return label;
                            }
                        }
                    }
            },
            scales: {
                x: props.axes?.label?.type?.startsWith("date")
                    ? {
                        type: "time",
                        time: {
                            unit: props.axes.label.type.split(".")[1] as "day" | "week" | "month"
                        }
                    }
                    : undefined,
                y: {
                    beginAtZero: true,
                    min: props.axes?.value?.limits?.min,
                    max: props.axes?.value?.limits?.max,
                    ticks: {
                        stepSize: stepSize.value,
                        callback: tickValue => {
                            if (typeof tickValue !== "number") {
                                tickValue = Number(tickValue);
                            }

                            if (isNaN(tickValue)) {
                                // If it's not a number, return the original value.
                                return `${tickValue}`;
                            }
                            else if (props.axes?.value?.type === "percent") {
                                return tickValue.toLocaleString(undefined, { style: "percent", maximumFractionDigits: props.axes?.value?.maxDecimalPlaces });
                            }
                            else {
                                return tickValue.toLocaleString(undefined, { maximumFractionDigits: props.axes?.value?.maxDecimalPlaces });
                            }
                        }
                    }
                }
            }
        };
    });

    const stepSize = computed<number | undefined>(() => {
        const coarseTicks = props.axes?.value?.ticks?.coarse;
        const fineTicks = props.axes?.value?.ticks?.fine;
        const min = props.axes?.value?.limits?.min;
        const max = props.axes?.value?.limits?.max;

        if ((!isNullish(min) && !isNullish(max)) && (!isNullish(coarseTicks) || !isNullish(fineTicks))) {

            const middleValue = (min + max) / 2;
            const maxValue = Enumerable.from(props.modelValue).max(d => d.value);

            if (!isNullish(maxValue)) {
                if (maxValue >= middleValue && !isNullish(coarseTicks)) {
                    return coarseTicks;
                }
                else if (maxValue < middleValue && !isNullish(fineTicks)) {
                    return fineTicks;
                }
            }
        }
    });

    // #endregion Computed Values

    // #region Functions

    /**
     * Gets the CSS variable value.
     *
     * @param name The name of the CSS variable.
     * @param fallback The fallback value to use.
     */
    function getCssVar(name: string, fallback: string): string {
        const computedStyle = getComputedStyle(document.documentElement)
            .getPropertyValue(name)
            .trim();

        return computedStyle || fallback;
    }

    // #endregion Functions
</script>