<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <div v-if="isVisible" :class="quickFilterClasses">
        <button type="button"
                title="Search"
                :class="quickFilterButtonClasses"
                @click.stop.prevent="onSearchClick">
            <i class="ti ti-search ti-fw"></i>
        </button>

        <div ref="quickFilterContainerElement"
             class="quick-filter-search"
             :class="{ 'quick-filter-open': isSearchExpanded }">
            <!--
                The form is here to prevent iOS from causing the Return key
                to become a Go key and triggering a WebForms postback.
            -->
            <RockForm>
                <TextBox v-model="quickFilterValue" placeholder="Search" />
            </RockForm>
        </div>
    </div>
</template>

<script setup lang="ts">
    import { computed, nextTick, onBeforeUnmount, onMounted, PropType, ref } from "vue";
    import RockForm from "@Obsidian/Controls/rockForm.obs";
    import TextBox from "@Obsidian/Controls/textBox.obs";

    const props = defineProps({
        /**
         * The current text being used for the quick filter search box.
         * The quick filter will only be shown if this value is not undefined.
         */
        modelValue: {
            type: String as PropType<string | undefined>,
            default: undefined
        },

        /** Additional CSS classes to apply to the quick filter container element. */
        quickFilterClass: {
            type: String as PropType<string>,
            default: ""
        },

        /** Additional CSS classes to apply to the quick filter button element. */
        quickFilterButtonClass: {
            type: String as PropType<string>,
            default: ""
        }
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: string): void;
    }>();

    // #region Values

    const quickFilterContainerElement = ref<HTMLElement>();
    const isSearchExpanded = ref(false);

    // #endregion Values

    // #region Computed Values

    const isVisible = computed((): boolean => {
        return typeof props.modelValue !== "undefined";
    });

    const quickFilterClasses = computed((): string[] => {
        const classes = ["quick-filter"];

        if (isSearchExpanded.value) {
            classes.push("quick-filter-active");
        }

        if (props.quickFilterClass) {
            classes.push(props.quickFilterClass);
        }

        return classes;
    });

    const quickFilterButtonClasses = computed((): string[] => {
        const classes = ["btn", "btn-quick-filter"];

        if (isSearchExpanded.value) {
            classes.push("active");
        }

        if (props.quickFilterButtonClass) {
            classes.push(props.quickFilterButtonClass);
        }

        return classes;
    });

    const quickFilterValue = computed<string>({
        get: () => {
            return props.modelValue ?? "";
        },
        set: (value: string) => {
            if (value !== props.modelValue) {
                emit("update:modelValue", value);
            }
        }
    });

    // #endregion Computed Values

    // #region Functions

    /**
     * Checks if the element or any ancestor can be focused. This is a rough
     * guess and not 100% accurate, but should be good enough for our uses.
     *
     * @param element The element whose ancestor tree is to be checked for focusability.
     *
     * @returns `true` if the element or any ancestor is focusable, otherwise `false`.
     */
    function isTreeFocusable(element: HTMLElement | null): boolean {
        while (element != null) {
            if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
                return true;
            }

            if (element.isContentEditable) {
                return true;
            }

            element = element.parentElement;
        }

        return false;
    }

    // #endregion Functions

    // #region Event Handlers

    /**
     * Called when the quick filter search button is clicked. Toggle the
     * visible state of the search box.
     */
    function onSearchClick(): void {
        // Don't allow hiding the search box if there is content in it.
        if (isSearchExpanded.value && quickFilterValue.value) {
            return;
        }

        isSearchExpanded.value = !isSearchExpanded.value;

        // Focus the search box if it is visible.
        if (isSearchExpanded.value) {
            nextTick(() => {
                const searchBox = quickFilterContainerElement.value?.querySelector(".quick-filter input") as HTMLInputElement | null;
                searchBox?.focus();
            });
        }
    }

    /**
     * Event handler for when a key down event occurs anywhere in the document.
     *
     * @param event The keyboard event.
     */
    function onDocumentKeyDown(event: KeyboardEvent): void {
        // If it's not any kind of HTML Element, then just ignore it.
        if (!(event.target instanceof HTMLElement)) {
            return;
        }

        // If the quick filter has the focus, investigate further.
        if (quickFilterContainerElement.value?.contains(event.target)) {
            if (event.key === "Escape") {
                // If the escape key is pressed then clear the search.
                if (quickFilterValue.value === "") {
                    const searchBox = quickFilterContainerElement.value?.querySelector(".quick-filter input") as HTMLInputElement | null;

                    searchBox?.blur();
                    isSearchExpanded.value = false;
                }
                else {
                    quickFilterValue.value = "";
                }
            }
            else if (event.key === "Enter") {
                // If the enter/return key is pressed, it signifies the individual
                // is done typing and is ready to "search"; if the event is not
                // cancelled, this can lead to other grid actions (i.e. row delete)
                // from trying to handle the event.
                event.preventDefault();
            }
        }

        // If no other input type element has focus and they hit the hotkey
        // for searching, quick-filter-open the search bar and focus the search box.
        if (!isTreeFocusable(event.target)) {
            if (event.key === "F" && event.ctrlKey && event.shiftKey) {
                isSearchExpanded.value = true;

                nextTick(() => {
                    const searchBox = quickFilterContainerElement.value?.querySelector(".quick-filter input") as HTMLInputElement | null;
                    searchBox?.focus();
                });
            }
        }
    }

    // #endregion Event Handlers

    onMounted(() => {
        document.addEventListener("keydown", onDocumentKeyDown);
    });

    onBeforeUnmount(() => {
        document.removeEventListener("keydown", onDocumentKeyDown);
    });
</script>
