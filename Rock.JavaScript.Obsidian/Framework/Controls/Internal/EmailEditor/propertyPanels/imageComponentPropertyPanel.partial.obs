<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <ComponentPropertyPanelBase :componentElement="componentElement"
                                :ltr="ltr"
                                title="Image"
                                @clone="$emit('clone')"
                                @complete="$emit('complete')"
                                @delete="$emit('delete')"
                                @migrate="$emit('migrate', $event)">
        <AccordionGroup>
            <Accordion title="Settings">
                <div class="form-group">
                    <ButtonGroup v-model="imageSourceType"
                                 :items="imageSourceTypes" />
                </div>

                <template v-if="imageSourceType === 'file'">
                    <ImageUploader v-model="imageFile"
                                   :binaryFileTypeGuid="imageComponentBinaryFileTypeGuid"
                                   label="Choose Image"
                                   :uploadAsTemporary="false" />
                    <p class="text-sm text-muted">
                        *For best results, use static images ~600px wide, &lt;1MB. Avoid text overlays, patterns, or animations; they may not display correctly in some email clients.
                    </p>
                </template>

                <div v-else-if="imageSourceType === 'asset'">
                    <AssetPicker v-model="imageAsset"
                                 label="Choose Asset" />
                </div>

                <div class="row">
                    <div class="col-sm-12">
                        <TextBox v-model="href"
                                 help="Add the URL that the image will direct the recipient to."
                                 label="Link">
                            <template #inputGroupPrepend>
                                <span class="input-group-addon">
                                    <i class="ti ti-link"></i>
                                </span>
                            </template>
                        </TextBox>
                    </div>

                    <div class="col-sm-12">
                        <TextBox v-model="altText"
                                 help="Provide a brief description of the image or for better accessibility. Keep it concise and relevant."
                                 label="Alt Text"
                                 placeholder="Add image description..." />
                    </div>
                </div>

                <div class="row">
                    <div class="col-sm-6">
                        <DropDownList v-model="imageSizeType"
                                      help="Choose how the image is displayed: Responsive fills the available space, Fixed trims/fits to dimensions, Original keeps the natural size."
                                      :items="imageSizeItems"
                                      label="Image Size"
                                      :showBlankItem="false" />
                    </div>
                </div>

                <template v-if="imageSize.type === 'responsive'">
                    <div class="row">
                        <div class="col-sm-12">
                            <Switch v-if="imageSourceType === 'file'"
                                    v-model="isHighResEnabled"
                                    text="Enable High-Res Images" />
                        </div>
                    </div>
                </template>

                <template v-else-if="imageSize.type === 'fixed'">
                    <div class="row">
                        <div class="col-sm-6">
                            <NumberBox v-model="imageWidth"
                                       label="Width">
                                <template #inputGroupAppend>
                                    <span class="input-group-addon">px</span>
                                </template>
                            </NumberBox>
                        </div>
                        <div class="col-sm-6">
                            <NumberBox v-model="imageHeight"
                                       label="Height">
                                <template #inputGroupAppend>
                                    <span class="input-group-addon">px</span>
                                </template>
                            </NumberBox>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-sm-12">
                            <Switch v-if="imageSourceType === 'file'"
                                    v-model="isHighResEnabled"
                                    text="Enable High-Res Images" />
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-sm-6">
                            <DropDownList v-model="resizeMode"
                                          help="How the image fits its box: Cover fills by cropping, Contain fits without cropping, Stretch scales to fill."
                                          :items="resizeModeItems"
                                          label="Resize Mode"
                                          :showBlankItem="false" />
                        </div>
                    </div>
                </template>

                <div class="row">
                    <div class="col-sm-12">
                        <HorizontalAlignmentPicker v-model="horizontalAlignment" />
                    </div>
                </div>

                <div class="row">
                    <div class="col-sm-12">
                        <ShorthandPixelBox v-model="borderRadiusPx"
                                           help="Rounded corners may not display correctly in some versions of Outlook or Windows Mail."
                                           label="Border Radius"
                                           topLabel="Top-Left"
                                           bottomLabel="Top-Right"
                                           leftLabel="Bottom-Left"
                                           rightLabel="Bottom-Right" />
                    </div>
                </div>
            </Accordion>

            <Accordion title="Spacing">
                <div class="row">
                    <div class="col-sm-12">
                        <ShorthandPixelBox v-model="marginPx"
                                           label="Margin" />
                    </div>
                </div>
            </Accordion>

            <Accordion title="Border">
                <BorderPicker v-model="border" />
            </Accordion>
        </AccordionGroup>
    </ComponentPropertyPanelBase>
</template>

<script setup lang="ts">
    import { computed, PropType, ref, watch } from "vue";
    import ComponentPropertyPanelBase from "./componentPropertyPanelBase.partial.obs";
    import Accordion from "../accordion.partial.obs";
    import AccordionGroup from "../accordionGroup.partial.obs";
    import BorderPicker from "../borderPicker.partial.obs";
    import HorizontalAlignmentPicker from "../horizontalAlignmentPicker.partial.obs";
    import ShorthandPixelBox from "../shorthandPixelBox.partial.obs";
    import { BorderModel, HorizontalAlignment, ImageSizeModel, ImageSourceModel, ResizeMode, ShorthandModel } from "../types.partial";
    import { createImageComponentAdapter, get } from "../utils.partial";
    import AssetPicker from "@Obsidian/Controls/Internal/assetPicker.obs";
    import ButtonGroup from "@Obsidian/Controls/buttonGroup.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import ImageUploader from "@Obsidian/Controls/imageUploader.obs";
    import NumberBox from "@Obsidian/Controls/numberBox.obs";
    import Switch from "@Obsidian/Controls/switch.obs";
    import TextBox from "@Obsidian/Controls/textBox.obs";
    import { Guid } from "@Obsidian/Types";
    import { FileAsset } from "@Obsidian/ViewModels/Controls/fileAsset";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    // #region Types

    type ImageSizeType = ImageSizeModel["type"];
    type ImageSourceType = ImageSourceModel["type"];

    // #endregion Types

    const props = defineProps({
        componentElement: { type: Object as PropType<HTMLElement>, required: true },
        imageComponentBinaryFileTypeGuid: { type: String as PropType<Guid>, required: true },
        ltr: { type: Boolean as PropType<boolean>, default: false }
    });

    defineEmits<{ (e: "clone"): void; (e: "complete"): void; (e: "delete"): void; (e: "migrate", value: Element): void }>();

    const imageComponentAdapter = createImageComponentAdapter();

    // #region Constants

    // Don't type this because the ButtonGroup above expects a privately defined type
    const imageSourceTypes = [
        { text: "Image", value: get<ImageSourceType>("file") },
        { text: "Asset", value: get<ImageSourceType>("asset") }
    ];

    const resizeModeItems: ListItemBag[] = [
        { text: "Cover", value: get<ResizeMode>("crop") },
        { text: "Contain", value: get<ResizeMode>("pad") },
        { text: "Stretch", value: get<ResizeMode>("stretch") }
    ];

    const imageSizeItems: ListItemBag[] = [
        { text: "Responsive", value: get<ImageSizeType>("responsive") },
        { text: "Fixed", value: get<ImageSizeType>("fixed") },
        { text: "Original", value: get<ImageSizeType>("original") }
    ];

    // #endregion Constants

    // #region Values

    const initialLocalProps = imageComponentAdapter.readLocalProps(props.componentElement);
    const altText = ref<string>(initialLocalProps.altText);
    const border = ref<BorderModel | null>(initialLocalProps.border);
    const borderRadiusPx = ref<ShorthandModel<number | null> | null>(initialLocalProps.borderRadiusPx);
    const horizontalAlignment = ref<HorizontalAlignment | "">(initialLocalProps.horizontalAlignment ?? "");
    const href = ref<string>(initialLocalProps.href ?? "");
    const imageSize = ref<ImageSizeModel>(initialLocalProps.imageSize);
    const imageSource = ref<ImageSourceModel>(initialLocalProps.imageSource);
    const marginPx = ref<ShorthandModel<number | null> | null>(initialLocalProps.marginPx);

    // #endregion Values

    // #region Computed Values

    const imageFile = computed<ListItemBag | undefined>({
        get(): ListItemBag | undefined {
            return imageSource.value.type === "file" ? imageSource.value.file ?? undefined : undefined;
        },
        set(value: ListItemBag | undefined) {
            imageSource.value = {
                type: "file",
                isHighResolution: imageSource.value.type === "file" ? imageSource.value.isHighResolution : false,
                file: value ?? null
            };
        }
    });

    const imageAsset = computed<FileAsset | undefined>({
        get(): FileAsset | undefined {
            return imageSource.value.type === "asset" ? imageSource.value.asset ?? undefined : undefined;
        },
        set(value: FileAsset | undefined) {
            imageSource.value = {
                type: "asset",
                asset: value ?? null
            };
        }
    });

    const imageSourceType = computed<ImageSourceType>({
        get(): ImageSourceType {
            return imageSource.value.type === "asset" ? "asset" : "file";
        },
        set(value: ImageSourceType) {
            if (value === "asset") {
                imageSource.value = {
                    type: "asset",
                    asset: null
                };
            }
            else {
                imageSource.value = {
                    type: "file",
                    isHighResolution: false,
                    file: null
                };
            }
        }
    });

    const imageSizeType = computed<ImageSizeType>({
        get(): ImageSizeType {
            return imageSize.value.type;
        },
        set(value: ImageSizeType) {
            if (value === "original") {
                imageSize.value = {
                    type: "original"
                };
            }
            else if (value === "fixed") {
                imageSize.value = {
                    type: "fixed",
                    fixedWidthPx: null,
                    fixedHeightPx: null,
                    resizeMode: "crop"
                };
            }
            else {
                imageSize.value = {
                    type: "responsive"
                };
            }
        }
    });

    const resizeMode = computed<ResizeMode>({
        get(): ResizeMode {
            return imageSize.value.type === "fixed" ? imageSize.value.resizeMode : "crop";
        },
        set(value: ResizeMode) {
            if (imageSize.value.type === "fixed") {
                imageSize.value = {
                    type: "fixed",
                    fixedWidthPx: imageSize.value.fixedWidthPx,
                    fixedHeightPx: imageSize.value.fixedHeightPx,
                    resizeMode: value
                };
            }
        }
    });

    const imageWidth = computed<number | null>({
        get(): number | null {
            return imageSize.value.type === "fixed" ? imageSize.value.fixedWidthPx : null;
        },
        set(value: number | null) {
            if (imageSize.value.type === "fixed") {
                imageSize.value = {
                    type: "fixed",
                    fixedWidthPx: value,
                    fixedHeightPx: imageSize.value.fixedHeightPx,
                    resizeMode: imageSize.value.resizeMode
                };
            }
        }
    });

    const imageHeight = computed<number | null>({
        get(): number | null {
            return imageSize.value.type === "fixed" ? imageSize.value.fixedHeightPx : null;
        },
        set(value: number | null) {
            if (imageSize.value.type === "fixed") {
                imageSize.value = {
                    type: "fixed",
                    fixedWidthPx: imageSize.value.fixedWidthPx,
                    fixedHeightPx: value,
                    resizeMode: imageSize.value.resizeMode
                };
            }
        }
    });

    const isHighResEnabled = computed<boolean>({
        get(): boolean {
            return imageSource.value.type === "file" ? imageSource.value.isHighResolution : false;
        },
        set(value: boolean) {
            if (imageSource.value.type === "file") {
                imageSource.value = {
                    type: "file",
                    isHighResolution: value,
                    file: imageSource.value.file,
                };
            }
        }
    });

    // #endregion Computed Values

    // #region Watchers

    watch(() => props.componentElement, () => {
        const updatedLocalProps = imageComponentAdapter.readLocalProps(props.componentElement);
        altText.value = updatedLocalProps.altText;
        border.value = updatedLocalProps.border;
        borderRadiusPx.value = updatedLocalProps.borderRadiusPx;
        horizontalAlignment.value = updatedLocalProps.horizontalAlignment ?? "";
        href.value = updatedLocalProps.href ?? "";
        imageSize.value = updatedLocalProps.imageSize;
        imageSource.value = updatedLocalProps.imageSource;
        marginPx.value = updatedLocalProps.marginPx;
    });

    // When Image Size changes away from "fixed", clear width/height
    watch([altText,
        border,
        borderRadiusPx,
        horizontalAlignment,
        href,
        imageSize,
        imageSource,
        marginPx], () => {
            imageComponentAdapter.writeLocalProps(props.componentElement, {
                altText: altText.value,
                border: border.value,
                borderRadiusPx: borderRadiusPx.value,
                horizontalAlignment: horizontalAlignment.value || null,
                href: href.value || null,
                imageSize: imageSize.value,
                imageSource: imageSource.value,
                marginPx: marginPx.value
            });
    });

    // #endregion Watchers
</script>
