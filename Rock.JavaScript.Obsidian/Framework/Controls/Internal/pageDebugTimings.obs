<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Modal v-model="showTimingsModal"
           title="Page Debug Timings"
           cancelText="Close">
        <table class="table table-bordered table-striped debug-timings" style="width:100%; margin-bottom: 48px;">
            <thead>
                <tr>
                    <th class="debug-timestamp">Timestamp</th>
                    <th>Event</th>
                    <th class="debug-timestamp">Duration</th>
                    <th class="debug-waterfall">Waterfall</th>
                </tr>
            </thead>
            <tbody>
                <PageDebugTimingRow v-for="(vm, i) in serverViewModels" :key="`s${i}-${vm.timestampMs}`" :viewModel="vm" :totalMs="clientRelativeEndTimeMs" />
                <PageDebugTimingRow :viewModel="clientHeader" :totalMs="clientRelativeEndTimeMs" />
                <PageDebugTimingRow v-for="(vm, i) in relativeClientViewModels" :key="`c${i}-${vm.timestampMs}`" :viewModel="vm" :totalMs="clientRelativeEndTimeMs" />
            </tbody>
        </table>
    </Modal>
</template>

<style>
.debug-timestamp {
    text-align: right;
    text-wrap: nowrap;
}

td.debug-waterfall {
    width: 40%;
    position: relative;
    vertical-align: middle !important;
    padding: 0 !important;
}

.debug-chart-bar {
    position: absolute;
    display: block;
    min-width: 1px;
    height: 1.125em;
    background: #009ce3;
    margin-top: -0.5625em;
}
</style>

<script setup lang="ts">
    import Modal from "@Obsidian/Controls/modal.obs";
    import PageDebugTimingRow from "./pageDebugTimingRow.obs";
    import { computed, PropType, ref } from "vue";
    import { DebugTiming } from "@Obsidian/ViewModels/Utility/debugTiming";
    import { useStore } from "@Obsidian/PageState";

    const store = useStore();

    const props = defineProps({
        serverViewModels: {
            type: Array as PropType<DebugTiming[]>,
            required: true
        }
    });

    const showTimingsModal = ref(true);

    const serverEndTimeMs = computed((): number => {
        if (!props.serverViewModels.length) {
            return 0;
        }

        const lastIndex = props.serverViewModels.length - 1;
        const lastViewModel = props.serverViewModels[lastIndex];
        return lastViewModel.timestampMs + lastViewModel.durationMs;
    });

    const firstClientRelativeStartTimeMs = computed((): number => {
        if (!relativeClientViewModels.value.length) {
            return serverEndTimeMs.value;
        }

        const viewModel = relativeClientViewModels.value[0];
        return viewModel.timestampMs;
    });

    const clientRelativeEndTimeMs = computed((): number => {
        if (!relativeClientViewModels.value.length) {
            return serverEndTimeMs.value;
        }

        const lastIndex = relativeClientViewModels.value.length - 1;
        const lastViewModel = relativeClientViewModels.value[lastIndex];
        return lastViewModel.timestampMs + lastViewModel.durationMs;
    });

    const clientViewModels = computed((): DebugTiming[] => {
        return store.state.debugTimings;
    });

    const relativeClientViewModels = computed((): DebugTiming[] => {
        // Add the server end time so they appear after the server
        return clientViewModels.value.map(vm => ({
            ...vm,
            timestampMs: serverEndTimeMs.value + vm.timestampMs
        } as DebugTiming));
    });

    const clientHeader = computed((): DebugTiming => {
        return {
            durationMs: firstClientRelativeStartTimeMs.value - serverEndTimeMs.value,
            indentLevel: 0,
            isTitleBold: true,
            title: "Client Mount Blocks",
            timestampMs: serverEndTimeMs.value,
            subTitle: ""
        };
    });
</script>
