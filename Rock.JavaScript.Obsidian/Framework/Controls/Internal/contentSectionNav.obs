<template>
    <div class="list-group contentsection-nav">
        <div class="contentsection-nav-header">
            <h5 class="contentsection-nav-header-title">Sections</h5>

            <span style="position: relative;">
                <button type="button" class="btn btn-action"
                        data-toggle="dropdown">
                    <i class="ti ti-dots-vertical"></i>
                </button>

                <ul class="dropdown-menu dropdown-menu-right">
                    <li v-if="autoCollapse">
                        <a href="#" @click.prevent="onToggleAutoCollapse(false)">
                            <i class="ti ti-viewport-short"></i>
                            Turn Off Auto Collapse
                        </a>
                    </li>
                    <li v-else>
                        <a href="#" @click.prevent="onToggleAutoCollapse(true)">
                            <i class="ti ti-viewport-short"></i>
                            Turn On Auto Collapse
                        </a>
                    </li>
                    <li :class="expandCollapseAllClasses">
                        <a href="#" @click.prevent="onExpandAllClick">
                            <i class="ti ti-chevrons-down"></i>
                            Expand All
                        </a>
                    </li>
                    <li :class="expandCollapseAllClasses">
                        <a href="#" @click.prevent="onCollapseAllClick">
                            <i class="ti ti-chevrons-up"></i>
                            Collapse All
                        </a>
                    </li>
                </ul>
            </span>
        </div>

        <a v-for="section in sections"
           :href="`#${section.anchor.value}`"
           class="list-group-item contentsection-nav-link"
           :class="{ active: section.anchor.value === activeSectionId }"
           @click.prevent.stop="onOpenSectionClick(section)">
            <i v-if="section.icon.value" :class="section.icon.value"></i>
            {{ section.title.value }}
        </a>
    </div>
</template>

<script setup lang="ts">
    import { IContentSectionHolder } from "@Obsidian/Core/Controls/contentSection";
    import { usePersonPreferences } from "@Obsidian/Utility/block";
    import { asBooleanOrNull } from "@Obsidian/Utility/booleanUtils";
    import { getCssVariableValue } from "@Obsidian/Utility/cssUtils";
    import { isNullish } from "@Obsidian/Utility/util";
    import { computed, nextTick, onBeforeUnmount, onMounted, PropType, ref, watch } from "vue";

    const props = defineProps({
        sections: {
            type: Array as PropType<IContentSectionHolder[]>,
            required: true
        },
        waitForTransitions: {
            type: Function as PropType<() => Promise<void>>,
            required: false
        }
    });

    const preferences = usePersonPreferences().blockPreferences;

    // #region Values

    const autoCollapse = ref(asBooleanOrNull(preferences.getValue("contentsection-auto-collapse")) ?? true);
    const activeSectionId = ref(window.location.hash.replace("#", ""));

    let headerOffsetPx: number | null = null;
    let resizeObserver: ResizeObserver | null = null;

    // #endregion Values

    // #region Computed Values

    const expandCollapseAllClasses = computed((): string => {
        return autoCollapse.value
            ? "disabled"
            : "";
    });

    // #endregion Computed Values

    // #region Functions

    /**
     * Scrolls the page to the specified section, accounting for any fixed or
     * sticky headers.
     * @param sectionId The ID of the section to scroll to.
     */
    function scrollToSection(sectionId: string): void {
        if (!sectionId) {
            return;
        }

        const element = document.getElementById(sectionId);
        if (element) {
            const offset = getFixedHeaderOffsetPx();
            const elementPosition = element.getBoundingClientRect().top + window.pageYOffset;
            const offsetPosition = elementPosition - offset;

            window.scrollTo({
                top: offsetPosition,
                behavior: "smooth"
            });
        }
    }

    /**
     * Calculates the total offset height of any fixed headers so we can avoid
     * them when scrolling to a section.
     * @returns The total offset in pixels.
     */
    function getFixedHeaderOffsetPx(): number {
        if (!isNullish(headerOffsetPx)) {
            return headerOffsetPx;
        }

        let offset = 0;

        // While this is not a perfect method of determining fixed header height,
        // our goal is to get close enough for most scenarios without requiring
        // additional configuration. This will scan the entire DOM for any
        // elements that are fixed at or above the top of the viewport (that's
        // actually in view, as determined by its bottom edge being below the
        // top of the viewport) and sum their heights.
        document.querySelectorAll("*").forEach(el => {
            const style = getComputedStyle(el);

            if (style.position === "fixed") {
                const rect = el.getBoundingClientRect();
                if (rect.top <= 0 && rect.bottom > 0) {
                    offset += rect.height;
                }
            }
        });

        // Add extra padding to ensure the section header is fully visible.
        var extraPaddingPx = parseInt(getCssVariableValue("--spacing-medium", "16"));

        headerOffsetPx = offset + extraPaddingPx;

        return headerOffsetPx;
    }

    // #endregion Functions

    // #region Event Handlers

    /**
     * Handles the hash change event to update the active section ID.
     */
    function onHashChange(): void {
        activeSectionId.value = window.location.hash.replace("#", "");
    }

    /**
     * Handles the click event on a section link to open the section.
     * This will automatically collapse other sections before opening the
     * clicked section.
     *
     * @param section The section that was clicked.
     */
    async function onOpenSectionClick(section: IContentSectionHolder): Promise<void> {
        // Disable animations for all sections to avoid jarring effects when
        // auto-scrolling to the selected section.
        props.sections.forEach(s => {
            s.isAnimationDisabled.value = true;
        });

        if (autoCollapse.value) {
            props.sections
                .filter(s => !!s.title.value)
                .forEach(s => {
                    if (s !== section) {
                        s.isCollapsed.value = true;
                    }
                });
        }

        section.isCollapsed.value = false;

        const id = section.anchor.value ?? "";

        const url = `${window.location.href.split("#")[0]}#${id}`;
        window.history.replaceState(null, "", url);

        activeSectionId.value = id;

        // Wait for Vue to flush DOM updates.
        await nextTick();

        // Wait for any ongoing transitions to complete.
        if (props.waitForTransitions) {
            await props.waitForTransitions();
        }

        scrollToSection(id);

        // Wait for Vue to flush DOM updates then re-enable animations.
        await nextTick();

        props.sections.forEach(s => {
            s.isAnimationDisabled.value = false;
        });
    }

    /**
     * Toggles the auto-collapse feature on and off.
     * If turning on auto-collapse and there is an active (previously-selected)
     * section, all but the active section will be collapsed.
     *
     * @param isEnabled Whether the auto-collapse feature is enabled.
     */
    function onToggleAutoCollapse(isEnabled: boolean): void {
        autoCollapse.value = isEnabled;

        if (!isEnabled || !activeSectionId.value) {
            return;
        }

        // Try to close all but the active section.
        const activeSection = props.sections.find(s =>
            s.anchor.value === activeSectionId.value
        );

        if (activeSection) {
            onOpenSectionClick(activeSection);
        }
    }

    /**
     * Handles the "Expand All" menu item click.
     * This will expand all sections.
     */
    function onExpandAllClick(): void {
        if (autoCollapse.value) {
            return;
        }

        props.sections.forEach(s => {
            s.isCollapsed.value = false;
        });
    }

    /**
     * Handles the "Collapse All" menu item click.
     * This will collapse all sections.
     */
    function onCollapseAllClick(): void {
        if (autoCollapse.value) {
            return;
        }

        props.sections.forEach(s => {
            s.isCollapsed.value = true;
        });
    }

    // #endregion Event Handlers

    watch(autoCollapse, () => {
        preferences.setValue("contentsection-auto-collapse", autoCollapse.value ? "true" : "false");
        preferences.save();
    });

    onMounted((): void => {
        window.addEventListener("hashchange", onHashChange);

        if (window.ResizeObserver) {
            const docEl = document.documentElement;
            let lastWidth = docEl.clientWidth;

            resizeObserver = new ResizeObserver(() => {
                const newWidth = docEl.clientWidth;
                if (newWidth !== lastWidth) {
                    // Clear the cached header offset so it will be recalculated
                    // on the next section selection.
                    headerOffsetPx = null;
                    lastWidth = newWidth;
                }
            });

            resizeObserver.observe(docEl);
        }
    });

    onBeforeUnmount((): void => {
        window.removeEventListener("hashchange", onHashChange);

        if (resizeObserver) {
            resizeObserver.disconnect();
            resizeObserver = null;
        }
    });
</script>
